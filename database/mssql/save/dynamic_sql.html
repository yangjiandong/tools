<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=windows-1252" lang="en-gb"><title>The curse and blessings of dynamic SQL</title>

<style type="text/css">
<!--
.allcaps {font-size: 90%;}

h2 {border-top: 2px dashed black;
    padding-top: 12pt;}

li {margin-bottom: 3 pt;
    margin-left: -10pt;}


pre {margin-left: 18pt;}



-->
</style></head><body>

<h1 align="center">The Curse and Blessings of Dynamic SQL</h1>
<p align="left"><font size="-1">An SQL text by <a href="http://www.sommarskog.se/index.html">Erland Sommarskog</a>,
SQL Server MVP.</font></p>
<p align="left"><font size="-1">An earlier version of this article is
   also available in <a href="http://itcontents.com/sommar/dynamic_SQL.html">
   Korean</a>,
   <a href="http://www.insidesql.de/content/view/164/29/">German</a>,
   <a href="http://www.hayes.ch/sql/sql_dinamico.html">Spanish</a> and
   <a href="http://vuhuytam.com/sql/dynamic_sql.html">Vietnamese</a>. Translations
   provided by ASP MVP Jongshin Kim, SQL Server MVP Frank Kalis, Simon Hayes and 
   Tam Vu respectively.</font></p>
<p align="left">If you follow the various newsgroups on Microsoft <small class="allcaps">SQL</small> Server,
you often see people asking why they can't do:</p>
<pre>SELECT * FROM @tablename
SELECT @colname FROM tbl
SELECT * FROM tbl WHERE x IN (@list)</pre>
<p>For all three examples you can expect someone to answer <i>Use dynamic <small class="allcaps">SQL</small></i>
   and give a quick example on how to do it. Unfortunately, for all three examples
   above, dynamic <small class="allcaps">SQL</small> is a poor solution.
   On the other hand, there are situations where dynamic <small class="allcaps">SQL</small> 
   is the best or only way to go. </p>
<p align="left">In this article I will discuss the of use dynamic <small class="allcaps">SQL</small> 
   in stored procedures and to a minor extent from client languages. To set the 
   scene, I start with a very quick overview on application
   architecture for data access. I then proceed to describe the feature dynamic 
   <small class="allcaps">SQL</small> as such,
   with a quick introduction followed by the gory syntax details. Next, I continue with a discussion on <small class="allcaps">SQL</small> injection, a
   security issue that you absolutely must have good understanding of when
   you work with dynamic <small class="allcaps">SQL</small>. This is followed by a section where I discuss why
   we use stored procedures, and how that is affected by the use of dynamic <small class="allcaps">SQL</small>. 
   I carryon with a section on good practices and tips for writing
   dynamic <small class="allcaps">SQL</small>. I conclude by reviewing a number of 
   situations where you could use dynamic <small class="allcaps">SQL</small> and 
   whether it is a good or bad idea to do it.</p>
<p align="left">The article covers all versions of <small class="allcaps">SQL</small> Server from <small class="allcaps">SQL</small>&nbsp;6.5 to
   <small class="allcaps">SQL</small>&nbsp;2005, with emphasis on <small class="allcaps">SQL</small>&nbsp;2000 and <small class="allcaps">SQL</small>&nbsp;2005. </p>

<h4>Contents:</h4>
<contents>
&nbsp;&nbsp;&nbsp;<b><a href="#forks">Accessing a Data from an Application</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="#Introducing">Introducing Dynamic <small class="allcaps">SQL</small></a></b><br>
<small style="font-size: 90%;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FirstEncounter">A First Encounter</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sp_executesql">sp_executesql</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#EXEC4"><nobr>EXEC()</nobr></a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="#SQL_injection"><small class="allcaps">SQL</small> Injection – a Serious Security Issue</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="#storedprocedures">Dynamic <small class="allcaps">SQL</small> and Stored Procedures</a></b><br>
<small style="font-size: 90%;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#permissions">The Permission System</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#queryplans">Caching Query Plans</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#networktraffic">Reducing Network Traffic</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encapsulation">Encapsulating Logic</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trackability">Keeping Track of what Is Used</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#easiness">Easiness of Writing SQL Code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#supportability">Addressing Bugs and Problems</a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="#good_practices">Good Coding Practices and Tips for Dynamic <small class="allcaps">SQL</small></a></b><br>
<small style="font-size: 90%;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#debugprints">Use Debug Prints!</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nestedstrings">Nested Strings</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#formatting">Spacing and Formatting</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#objectnames">Dealing with Dynamic Table and Column Names</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#quotestring">Quotename, Nested Strings and Quotestring</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#QUOTED_IDENTIFIER">QUOTED_IDENTIFIER</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sp_executesqlong">sp_executesql and Long SQL Strings in SQL 2000</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#UDF">Dynamic SQL in User-Defined Functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cursor0">Cursors and Dynamic SQL</a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="#EXECatlinked"><small class="allcaps"><nobr>EXEC()</nobr></small> at Linked Server</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="#Common_cases">Common Cases when to (Not) Use Dynamic <small class="allcaps">SQL</small></a></b><br>
<small style="font-size: 90%;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Dyn_table">SELECT * FROM @tablename</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Sales_yymm">SELECT * FROM sales + @yymm</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Dyn_update">UPDATE tbl SET @colname = @value WHERE keycol = @keyval</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Dyn_DB">SELECT * FROM @dbname + '..tbl'</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#List">SELECT * FROM tbl WHERE col IN (@list)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Condition">SELECT * FROM tbl WHERE @condition</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Dyn_search">Dynamic Search Conditions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Order_by">SELECT * FROM tbl ORDER BY @col</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Top">SELECT TOP @n FROM tbl</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Cre_tbl">CREATE TABLE @tbl</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#unknowncolumns">CREATE TABLE with Unknown Columns</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#linkservers">Linked Servers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#OPENQUERY">OPENQUERY</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Col_width">Dynamic Column Widths</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#maintenancetasks">Dynamic SQL and Maintenance Tasks</a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="#Feedback">Acknowledgements and Feedback</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="#revisions">Revision History</a></b>
</contents>
<p>Note: many of
   the code samples in this text works against the <b>pubs</b> and <b>Northwind</b> databases
   that ship with <small class="allcaps">SQL</small>&nbsp;2000 and <small class="allcaps">SQL</small>&nbsp;7, but not with <small class="allcaps">SQL</small>&nbsp;2005. You can download
   these databases from
   <a href="http://www.microsoft.com/downloads/info.aspx?na=22&amp;p=1&amp;SrcDisplayLang=en&amp;SrcCategoryId=&amp;SrcFamilyId=&amp;u=/downloads/details.aspx?FamilyID=06616212-0356-46a0-8da2-eebc53a68034&amp;DisplayLang=en">
   Microsoft's web site</a>. <br>

</p>

<h2><a name="forks">Accessing a Data from an Application</a></h2>
<p>Before I describe dynamic <small class="allcaps">SQL, I</small> like to briefly discuss the various ways you can
   access data from an application to give an overview of what I'll be
   talking about in this article.</p>
<p>(<b>Note</b>: all through this text I will
   refer to <i>client</i> as anything that accesses <small class="allcaps">SQL</small> Server from the outside. 
   In the overall application architecture that may in fact be a middle tier or 
   a business layer, but as that is of little interest to this article, I use <i>
   client</i> in the sake of brevity.) </p>
<p>There are two main roads to go, and then there are forks and sub-forks.</p>
<ol type="1">
   <li>Send <small class="allcaps">SQL</small> statements from the client to <small class="allcaps">SQL</small>
      Server.
   <ol type="a">
       <li>Rely on <small class="allcaps">SQL</small> generated by the client <small class="allcaps">API</small>, using options like
          <b>CommandType</b>.<b>TableDirect</b> and methods like .<b>Update</b>.</li>
       <li>Compose the <small class="allcaps">SQL</small> strings in the client code.
       <ol type="i">
          <li>Build the entire <small class="allcaps">SQL</small> string with parameter values expanded.</li>
          <li>Use parameterised queries.</li>
       </ol></li>
   </ol></li>
   <li>Perform access through stored procedures.</li>
   <ol type="a">
       <li>Stored procedures in <small class="allcaps"><nobr>T-SQL</nobr></small></li>
       <ol type="i">
         <li>Use static <small class="allcaps">SQL</small> only.</li>
         <li>Use dynamic <small class="allcaps">SQL</small> together with static <small class="allcaps">SQL</small>.</li>
       </ol>
       <li>Stored procedures in a <small class="allcaps">CLR</small> language such as C# or VB .Net. (<small class="allcaps">SQL</small>&nbsp;2005
          only.)</li>
   </ol>
</ol>
<p>Fork <nobr>1-a</nobr> may be good for simple tasks, but you are likely to
   find that you outgrow it as the complexity of your application increases.
   In any case, this approach falls entirely outside the scope of this article.</p>
<p>Many applications are built along the principles of fork <nobr>1-b</nobr>,
   and as long as you take the sub-fork <nobr>1-b-ii</nobr>, it does not have to
   be bad. (Why <nobr>1-b-i</nobr> is bad, is
   something I will come back to. Here I will just drop two keywords:
   <a href="#SQL_injection"><small class="allcaps">SQL</small>
   Injection</a> and <a href="#queryplans">Query-Plan Reuse</a>.) Nonetheless, in many shops the mandate is
   that you should use stored procedures. When you use stored procedures with
   only static <small class="allcaps">SQL</small>, users do
   not need direct permissions to access the tables, only permissions to execute the stored
   procedures, and thus you can use the stored procedure to control what users
   may and may not do.</p>
<p>The main focus for this text is sub-fork <nobr>2-a-ii</nobr>. When used
   appropriately, dynamic <small class="allcaps">SQL</small> in stored 
   procedures can be a powerful addition to static <small class="allcaps">SQL</small>. But some of the questions on the newsgroups leads to
   dynamic <small class="allcaps">SQL</small> in stored procedures that is so meaningless, that these people 
   would be better off with fork <nobr>1-b</nobr> instead.</p>
<p>Finally, fork <nobr>2-b</nobr>, stored procedures in the <small class="allcaps">CLR</small>, is in many
   regards very similar to fork <nobr>1-b</nobr>, since all data access from <small class="allcaps">CLR</small>
   procedures is through generated <small class="allcaps">SQL</small> strings, parameterised or unparameterised. If you have settled on <small class="allcaps">SQL</small>
   procedures for your application, there is little point in rewriting them into
   the <small class="allcaps">CLR</small>. However, <small class="allcaps">CLR</small> code can be a valuable supplement for tasks that are
   difficult to perform in <small class="allcaps"><nobr>T-SQL</nobr></small>, but you yet want to perform server-side. </p>
<h2><a name="Introducing">Introducing Dynamic SQL</a></h2>
<p>In this chapter I will first look at some quick examples of dynamic <small class="allcaps">SQL</small> and
   point out some very important implications of using dynamic <small class="allcaps">SQL</small>. I will then
   describe <b>sp_executesql</b> and <small class="allcaps"><nobr>EXEC()</nobr></small> in detail, the two commands you can use to
   invoke dynamic <small class="allcaps">SQL</small> from <small class="allcaps"><nobr>T-SQL</nobr></small>.</p>
<h3><a name="FirstEncounter">A First Encounter</a></h3>
<p>Understanding dynamic <small class="allcaps">SQL</small> itself is not difficult. Au contraire, it's rather
   too easy to use. Understanding the fine details, though, takes a little
   longer time. If you start out using dynamic <small class="allcaps">SQL</small> casually, you are bound to face
   accidents when things do not work as you have anticipated.</p>
<p>One of the problems
 listed in the introduction was how to write a stored procedure that takes a
   table name as its input. Here are two examples, based on the two ways to do dynamic <small class="allcaps">SQL</small> in
   Transact-<small class="allcaps">SQL</small>:</p>
<pre>CREATE PROCEDURE general_select1 @tblname sysname,
                                 @key     varchar(10) AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT col1, col2, col3 ' +
              ' FROM dbo.' + quotename(@tblname) +
              ' WHERE keycol = @key'
EXEC sp_executesql @sql, N'@key varchar(10)', @key</pre>
<pre>CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>Before I say anything else, permit me to point out that these are examples of
   <i><b>bad</b></i> usage of dynamic <small class="allcaps">SQL</small>. 
   Passing a table name as a parameter
   is not how you should write stored procedures, and one aim of this article is
   to explain this in detail. Also, the two examples are not equivalent. While 
   both examples are bad, the second
   example has several problems that the first does not have. What these
   problems are will be apparent as you read this text.</p>
<p>Whereas the above looks very simple and easy, there are some very important things
   to observe. The first thing is permissions. You may know that when you
   use stored procedures, users do not need permissions to access the tables accessed by the stored procedure. <b><i>This does not apply when
   you use dynamic <small class="allcaps">SQL</small>!</i></b> For the procedures above to execute
   successfully, the users must have <small class="allcaps">SELECT</small> permission on the table in @tblname. In <small class="allcaps">SQL</small>&nbsp;2000 and earlier this is an absolute rule with no
   way around it. <small class="allcaps">SQL</small>&nbsp;2005 provides alternative ways, something I will
   come
   back to in the section <i><a href="#permissions">The Permission System</a></i>.</p>
<p>Next thing to observe is that the dynamic <small class="allcaps">SQL</small> <b><i>is not part of
   the stored procedure</i></b>, but constitutes <i><b>its own scope</b></i>. Invoking a block
   of dynamic <small class="allcaps">SQL</small> is akin to call a nameless stored procedure created ad-hoc. This
   has a number of consequences:</p>
<ul>
  <li>Within the block of dynamic <small class="allcaps">SQL</small>, you cannot access local variables
     (including table variables) or parameters of the calling stored procedure.
     But you can pass parameters – in and out – to a block of dynamic <small class="allcaps">SQL</small> if you
     use <b>sp_executesql</b>.</li>
  <li>Any <small class="allcaps">USE</small> statement in the dynamic <small class="allcaps">SQL</small> will not affect the calling stored procedure.</li>
  <li>Temp tables created in the dynamic <small class="allcaps">SQL</small> will not be accessible from the
    calling procedure since they are dropped when the dynamic <small class="allcaps">SQL</small> exits.
     (Compare to how temp tables created in a stored procedure go away when you
     exit the procedure.) The block of
     dynamic <small class="allcaps">SQL</small> can however access temp tables created
     by the calling procedure.</li>
  <li>If you issue a <small class="allcaps">SET</small> command in the dynamic <small class="allcaps">SQL</small>, the effect of the <small class="allcaps">SET</small>
     command lasts for the duration of the block of dynamic <small class="allcaps">SQL</small> 
     only and does not affect the caller.</li>
  <li> The query plan for the stored procedure does not include the dynamic <small class="allcaps">SQL. 
     T</small>he block of dynamic <small class="allcaps">SQL</small> has a query plan of its own.</li>
 </ul>
<p>As you've seen there are two ways to invoke dynamic <small class="allcaps">SQL</small>, <b>sp_executesql</b> and
   <small class="allcaps"><nobr>EXEC()</nobr></small>. <b>sp_executesql</b> was added in <small class="allcaps">SQL</small>&nbsp;7, whereas <small class="allcaps"><nobr>EXEC()</nobr></small> has been around
   since <small class="allcaps">SQL</small>&nbsp;6.0. In application code, <b>sp_executesql</b> should be your choice 95%
   of the time for reasons that will prevail. For now I will only give two
   keywords: <a href="#SQL_injection"><small class="allcaps">SQL</small> Injection</a> and
   <a href="#queryplans">Query-Plan Reuse</a>. <small class="allcaps"><nobr>EXEC()</nobr></small> is mainly useful for quick throw-away things and <small class="allcaps">DBA</small> tasks, but also
   comes to the rescue in <small class="allcaps">SQL</small>&nbsp;2000 and <small class="allcaps">SQL</small>&nbsp;7 
   when the <small class="allcaps">SQL</small> string exceeds 4000 characters. And, obviously, in <small class="allcaps">SQL</small>&nbsp;6.5, <small class="allcaps"><nobr>EXEC()</nobr></small> is the sole choice. In the next
   two sections we will look at these two commands in detail.</p>

<h3><a name="sp_executesql">sp_executesql</a></h3>
<p><b>sp_executesql</b> is a built-in stored procedure that takes two
   pre-defined parameters and any number of user-defined parameters. </p>
<p>The first parameter <b>@stmt</b> is mandatory, and contains a batch of one or
 more <small class="allcaps">SQL</small> statements. The data type of @stmt is <b>ntext</b> in <small class="allcaps">SQL</small>&nbsp;7 and <small class="allcaps">SQL</small>&nbsp;2000,
 and <b>nvarchar(<small class="allcaps">MAX</small>)</b> in <small class="allcaps">SQL</small>&nbsp;2005. Beware that you must pass an <b>nvarchar</b>/<b>ntext</b>
 value (that is, a Unicode value). A <b>varchar</b> value won't do. </p>
<p>The second parameter <b>@params</b> is optional, but you will use it 90% of the
 time. @params declares the parameters that you refer to in @stmt. The syntax
 of @params is exactly the same as for the parameter list of a stored procedure. The
   parameters can
 have default values and they can have the <small class="allcaps">OUTPUT</small> marker. Not all parameters you declare must actually
   appear in the <small class="allcaps">SQL</small> string. (Whereas all variables that appear in the <small class="allcaps">SQL</small>
   string must be declared, either with a <small class="allcaps">DECLARE</small> inside @stmt, or in 
   @params.) Just like @stmt, the data
 type of @params in <small class="allcaps">SQL</small>&nbsp;7/2000 is <b>ntext</b> and <b>nvarchar(<small class="allcaps">MAX</small>)</b> in <small class="allcaps">SQL</small>&nbsp;2005.</p>
<p>The rest of the parameters are simply the parameters that you declared in
 @params, and you pass them as you pass parameters to a stored procedure, either
 positional or named. To get a value back from your output parameter, you must
   specify <small class="allcaps">OUTPUT</small> with the parameter, just like when you call a stored
   procedure. Note that @stmt and @params must be specified positionally. You
   can provide the parameter names for them, but these names are blissfully ignored.</p>
<p>Let's look at an example. Say that in your database, many tables
 have a column <i>LastUpdated</i>, which holds the time a row last was
 updated. You want to be able to find out how many rows in each table that were modified at
 least once during a period. This is not something you run as part of the application, but
   something you run as a <small class="allcaps">DBA</small> from time to time, so you just keep it as a script
   that you have a around. Here is how it could look like:</p>
<pre>DECLARE @tbl    sysname,
        <b>@sql    nvarchar(4000),
        @params nvarchar(4000)</b>,
        @count  int

DECLARE tblcur CURSOR STATIC LOCAL FOR
   SELECT object_name(id) FROM syscolumns WHERE name = 'LastUpdated'
   ORDER  BY 1
OPEN tblcur

WHILE 1 = 1
BEGIN
   FETCH tblcur INTO @tbl
   IF @@fetch_status &lt;&gt; 0
      BREAK

   <b>SELECT @sql =
   N' SELECT @cnt = COUNT(*) FROM dbo.' + quotename(@tbl) +
   N' WHERE LastUpdated BETWEEN @fromdate AND ' +
   N'                           coalesce(@todate, ''99991231'')'
   SELECT @params = N'@fromdate datetime, ' +
                    N'@todate   datetime = NULL, ' +
                    N'@cnt      int      OUTPUT'
   EXEC sp_executesql @sql, @params, '20060101', @cnt = @count OUTPUT
</b>
   PRINT @tbl + ': ' + convert(varchar(10), @count) + ' modified rows.'
END

DEALLOCATE tblcur</pre>
<p>I've put the lines that pertain directly to the dynamic <small class="allcaps">SQL</small> in bold face. You
   can see that I have declared the @sql and @params variables to be of the maximum
   length for <b>nvarchar</b> variables in <small class="allcaps">SQL</small>&nbsp;2000. In <small class="allcaps">SQL</small>&nbsp;2005, you may want to make it a routine to
   make @sql <b>nvarchar(<small class="allcaps">MAX</small>)</b>, more about this just below. </p>
<p>When I assign the @sql variable, I am careful to format the statement so that
   it is easy to read, and I leave in spaces to avoid that two concatenated
   parts are glued together without space in between, which could cause a syntax
   error. I put the table name in
   <a href="#objectnames"><nobr><b>quotename()</b></nobr></a> in case a table name has any special
   characters in it. I also prefix the table name with "<b>dbo</b>.", which is a good habit, as we will see when we look at dynamic <small class="allcaps">SQL</small> and
   <a href="#queryplans">query plans</a>. Overall, I will cover this sort of
   <a href="#good_practices">good practices</a> more in detail later in the text. Note also the appearance of <b>
   <code>''</code></b> around the date literal – the rule in <small class="allcaps"><nobr>T-SQL</nobr></small> is that to include the string
   delimiter in a string, you must double it.</p>
<p>In this example, the dynamic <small class="allcaps">SQL</small> has three parameters: one mandatory input
   parameter, one optional input parameter, and one
   output parameter. I've assumed that this time the <small class="allcaps">DBA</small> wanted to see
   all changes made after 2006-01-01, which is why I've left out @todate in the call
   to <b>sp_executesql</b>. Since I left out one variable, I must specify the last,
   @cnt by name – the same rules as when you call a stored procedure. Note also
   that the variable is called @cnt in the dynamic <small class="allcaps">SQL</small>, but @count in the
   surrounding script. Normally, you might want to use the same name, but I
   wanted to stress that the @cnt in the dynamic <small class="allcaps">SQL</small> is only visible within the
   dynamic <small class="allcaps">SQL</small>, whereas @count is <b><i>not</i></b> visible there.</p>
<p>You may note that I've prepend the string literals with <b>N</b> to denote that
   they are Unicode strings. As @sql and @params are declared as <b>nvarchar</b>,
   technically this is not necessary (as long as you stick your 8-bit character
   set). However, would you provide any of the strings directly in the call to
   <b>sp_executesql</b>, you must specify the N, as in this fairly silly example:</p>
<pre>EXEC sp_executesql N'SELECT @x', N'@x int', @x = 2</pre>
<p>If you remove any of the <b>N</b>s, you will get an error message. Since <b>sp_executesql</b> is a built-in stored procedure, there is no implicit
   conversion from <b>varchar</b>.</p>
<p>You may wonder why I do not pass @tbl as a parameter as well. The answer is
   that you can't. Dynamic <small class="allcaps">SQL</small> is just like any other <small class="allcaps">SQL</small>. You can't specify a
   table name through a variable in <small class="allcaps"><nobr>T-SQL</nobr></small>, that's the whole story. Thus, when you 
   need to specify things like table names, column names etc dynamically, 
   you must interpolate them into the string. </p>
<p>If you are on <small class="allcaps">SQL</small>&nbsp;2000 or <small class="allcaps">SQL</small>&nbsp;7, there is a limitation with <b>sp_executesql</b>
   when it comes to the length of the <small class="allcaps">SQL</small> string. While the parameter is <b>ntext</b>,
   you cannot use this data type for local variables. Thus, you will have to
   stick to <b>nvarchar(4000)</b>. In many cases this will do fine, but it is not
   uncommon to exceed that limit. In this case, you will need to use <small class="allcaps"><nobr>EXEC()</nobr></small>,
   described just below.</p>
<p>On <small class="allcaps">SQL</small>&nbsp;2005, this is not an issue. Here you can use the new data type
 <b>nvarchar(<small class="allcaps">MAX</small>)</b> which can hold as much data as <b>ntext</b>, 
   but without the many restrictions of <b>ntext</b>.</p>
<h3><a name="EXEC4"><nobr>EXEC()</nobr></a></h3>

<p><small class="allcaps"><nobr>EXEC()</nobr></small> takes one parameter which is an <small class="allcaps">SQL</small> statement to
   execute. The parameter can be a concatenation of
   string variables and string literals, but cannot include calls to functions 
   or other operators. For very simple
   cases, <small class="allcaps"><nobr>EXEC()</nobr></small> is less hassle than <b>sp_executesql</b>. For instance, say that you
   want to run <small class="allcaps">UPDATE STATISTICS WITH FULLSCAN</small> on some selected tables. It could
   look like this:</p>
<pre>FETCH tblcur INTO @tbl
IF @@fetch_status &lt;&gt; 0 BREAK
EXEC('UPDATE STATISTICS [' + @tbl + '] WITH FULLSCAN')</pre>
<p>In the example with <b>sp_executesql</b>, I used <nobr><b>qoutename()</b></nobr>, but here I've let it
   suffice with adding brackets, in case there is a table named <b>Order
   Details</b> (which there is in the <b>Northwind</b> database). Since <small class="allcaps">EXEC</small> only permits
   string literals and string variables to be concatenated and not arbitrary
   expressions, this is not legal:</p>
<pre>EXEC('UPDATE STATISTICS ' + <font color="#ff0000">quotename(@tbl)</font> + ' WITH FULLSCAN')</pre>
<p>Best practice is to always use a variable to hold the <small class="allcaps">SQL</small> statement, so the
   example would better read:</p>
<pre>FETCH tblcur INTO @tbl
IF @@fetch_status &lt;&gt; 0 BREAK
SELECT @sql = 'UPDATE STATISTICS ' + quotename(@tbl) + ' WITH FULLSCAN'
EXEC(@sql)</pre>
<p>The fact that you can concatenate strings within <small class="allcaps"><nobr>EXEC()</nobr></small> can permit you to
   make very quick things, which can be convenient at times, but can lead to
   poor habits in application code. However, there are situations where this is an
   enormous blessing. As I mentioned, in <small class="allcaps">SQL</small>&nbsp;7 and <small class="allcaps">SQL</small>&nbsp;2000, you can in practice
   only use 4000 characters in your <small class="allcaps">SQL</small> string with <b>sp_executesql</b>. <small class="allcaps">EXEC</small> does
   have this limitation, since you can say</p>
<pre>EXEC(@sql1 + @sql2 + @sql3)</pre>
<p>Where all of @sql1, @sql2 and @sql3 can be 4000 characters long – or even
   8000 characters as <small class="allcaps"><nobr>EXEC()</nobr></small> permits you to use <b>varchar</b>.</p>
<p>Since you cannot use parameters, you cannot as easily get values out from
   <small class="allcaps"><nobr>EXEC()</nobr></small> as you can with <b>sp_executesql</b>. You can, however, use <small class="allcaps">INSERT-EXEC</small>
   to insert the result set from <small class="allcaps"><nobr>EXEC()</nobr></small> into a table. I will show you an example
   <a href="#sp_executesqlong">later on</a>, when I also show you how you can
   use <small class="allcaps"><nobr>EXEC()</nobr></small> to pass longer strings than 4000 characters to <b>sp_executesql</b>.</p>
<p>In <small class="allcaps">SQL</small>&nbsp;2005, <small class="allcaps"><nobr>EXEC()</nobr></small> permits impersonation so that you can say:</p>
<pre>EXEC(@sql) AS USER = 'mitchell'
EXEC(@sql) AS LOGIN = 'CORDOBA\Miguel'</pre>
<p>This is mainly a syntactical shortcut that saves you from embedding the
   invocation of dynamic <small class="allcaps">SQL</small> in <small class="allcaps">EXECUTE AS</small> and <small class="allcaps">REVERT. (I</small> discuss these
   statements more in detail in my article <i>
   <a href="http://www.sommarskog.se/grantperm.html#EXECASstatement">Granting Permissions Through Stored
   Procedures</a></i>.)</p>
<p><small class="allcaps">SQL</small>&nbsp;2005 adds a valuable extension to <small class="allcaps"><nobr>EXEC()</nobr></small>: you can use 
   it to execute
   strings on <a href="#EXECatlinked">linked servers</a>. I will cover this form
   of <small class="allcaps"><nobr>EXEC()</nobr></small> in a separate section 
   later in this text. </p>
<h2><a name="Security2"></a><a name="SQL_injection">SQL Injection – a Serious Security Issue</a></h2>
<p>Before you start to use dynamic <small class="allcaps">SQL</small> all over town, you need to learn about <i>
   <small class="allcaps">SQL</small> injection </i>and how you protect your application against it. <small class="allcaps">SQL</small>
   injection is a technique whereby an intruder enters data that causes your application 
   to execute <small class="allcaps">SQL</small> statements you did not intend it to. <small class="allcaps">SQL</small> injection is possible as soon there is dynamic <small class="allcaps">SQL</small> which is
   handled carelessly, be that <small class="allcaps">SQL</small> statements sent from the client, dynamic <small class="allcaps">SQL</small>
   generated in <small class="allcaps"><nobr>T-SQL</nobr></small> stored procedures, or <small class="allcaps">SQL</small> batches executed from <small class="allcaps">CLR</small> stored
   procedures. This is not a line of attack that is unique to
   <small class="allcaps">MS SQL</small> Server, but all <small class="allcaps">RDBMS</small> are open to it.</p>
<p>Here is an example. The purpose of the procedure below is to permit users to 
   search for orders by various conditions. A real-life example of such a 
   procedure would have many more parameters, but I've cut it down to two to be 
   brief. (This is, by the way, a problem for which dynamic <small class="allcaps">SQL</small> is a very good 
   solution.) As the procedure is written, it is open for <small class="allcaps">SQL</small> injection:</p>
<pre>CREATE PROCEDURE search_orders @custid   nchar(5)     = NULL,
                               @shipname nvarchar(40) = NULL AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT OrderID, OrderDate, CustomerID, ShipName ' +
              ' FROM dbo.Orders WHERE 1 = 1 '
IF @custid IS NOT NULL
   SELECT @sql = @sql + ' AND CustomerID LIKE ''' + @custid + ''''
IF @shipname IS NOT NULL
   SELECT @sql = @sql + ' AND ShipName LIKE ''' + @shipame + ''''
EXEC(@sql)</pre>
<p>Before we look at a real attack, let's just discuss this from the point of view 
   of user-friendliness. Assume that the input for the parameters @custid and @shipname comes directly
   from the user and a naïve and innocent user wants to look for orders where <b>ShipName</b> is <i>Let's Stop N Shop</i>, so he enters <i>Let's</i>. Do you see
   what will happen? Because @shipname includes a single quote, he will get a
   syntax error. So even if you think that <small class="allcaps">SQL</small> injection is no issue to you,
   because you trust your users, you still need to read this section, so that they
   can search for Brian O'Brien and Samuel Eto'o. </p>
<p>So this is the starting point. A delimiter, usually a single quote, affects your dynamic <small class="allcaps">SQL</small>, and 
   a malicious user 
   can take benefit of this. For
   instance, consider this input for @shipname:</p>
<pre>' DROP TABLE Orders --</pre>
<p>The resulting <small class="allcaps">SQL</small> becomes:</p>
<pre>SELECT * FROM dbo.Orders WHERE 1 = 1  AND ShipName LIKE '' <font color="#ff0000">DROP TABLE orders</font> --'</pre>
 <p>This is a perfectly legal batch of <small class="allcaps"><nobr>T-SQL</nobr></small>, including the text in red. Of
    course, since there is something called permissions in <small class="allcaps">SQL</small> Server, this
    attack may or may not succeed. A plain
    user who runs a Windows application and who logs into <small class="allcaps">SQL</small> Server with his
    own login, is not likely to have
    permissions to drop a table. But it is not uncommon for web applications to
    have a general login that runs <small class="allcaps">SQL</small> queries on behalf of the users. And if this web app logs into <small class="allcaps">SQL</small> Server with <b>sysadmin</b> or <b>db_owner</b>
    privileges, the attack succeeds. Mind you, with <b>sysadmin</b> rights, the
    attacker can add users and logins as he pleases. And if the service account
    for <small class="allcaps">SQL</small> Server has admin privileges in Windows, the attacker has access into
    your network far beyond <small class="allcaps">SQL</small> Server through <b>xp_cmdshell</b>. (Which is
    disabled by default on <small class="allcaps">SQL</small>&nbsp;2005, but if the attacker has achieved
    <b>sysadmin</b> rights on the server, he can change that.)</p>
<p>Typically, an attacker first tests what happens
   if he enters a single quote (<code>'</code>) in an input field or a <small class="allcaps">URL</small>. If this
   yields a syntax error, the attacker knows that there is a vulnerability. He
   then finds out if he needs any extra tokens to terminate the query, and then
   he can add his own <small class="allcaps">SQL</small> statement. Finally he adds a comment character to kill
   the rest of the <small class="allcaps">SQL</small> string to avoid syntax errors. Single quote is the most
   common character to reveal openings for <small class="allcaps">SQL</small> injection, but if you have
   dynamic table and column names, there are more options an attacker could 
   succeed with.
   Take this dreadful version of <b>general_select</b>:</p>
<pre>CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>and assume that @tblname comes from a <small class="allcaps">URL</small>. There are quite some options that
   an attacker could use to take benefit of this hole. </p>
<p>And don't overlook numeric values: they can very well be used for <small class="allcaps">SQL</small> 
   injection. Of course, in a <small class="allcaps"><nobr>T-SQL</nobr></small> procedure where the value is passed as an 
   <b>int</b> parameter there is no risk, but if a supposedly numeric value is directly 
   interpolated into an <small class="allcaps">SQL</small> string in client code, there is a huge potential for 
   <small class="allcaps">SQL</small> injection.</p>
<p>Keep in mind that user input comes from more places than just input fields on
   a form. The most commonly used area for injection attacks on the Internet is
   probably parameters in URLs and cookies. Thus, be very careful how you handle 
   anything that comes from the user.</p>
<p>You may think that it takes not only skill, but also luck for someone to find
   and exploit a hole for <small class="allcaps">SQL</small> injection. But remember that there are too many hackers out there
   with too much time on their hands. <small class="allcaps">SQL</small> injection is a serious security issue, and you
   must take precautions to protect your applications against it.</p>
<p>Thankfully, it is not difficult at all. I've seen mentioning of various ways
   to validate input data, but all that is a joke. There are three steadfast
   principles you need to follow:</p>
<ul>
   <li>Never run with more privileges than necessary. Users that log into an
      application with their own login should normally only have <small class="allcaps">EXEC</small>
      permissions on stored procedures. If you use dynamic <small class="allcaps">SQL</small>, it should be
      confined to reading operations so that users only need <small class="allcaps">SELECT</small> permissions.
      A web site that logs into a database should not have any elevated
      privileges, preferably only <small class="allcaps">EXEC</small> and 
      (maybe) <small class="allcaps">SELECT</small> permissions. Never let the web site log in as <b>sa</b>!</li>
   <li>For web applications: never expose error messages from <small class="allcaps">SQL</small> Server to the 
      end user.</li>
   <li><i><b>Always used
      parameterised statements.</b></i> That is, in a <small class="allcaps"><nobr>T-SQL</nobr></small> procedure use <b>sp_executesql</b>,
      not <small class="allcaps"><nobr>EXEC()</nobr></small>. </li>
</ul>
<p>The first point is mainly a safeguard, so that if there is a injection hole,
   the intruder will not be able to do that much harm. The second point makes 
   the task for the attacker more difficult as he cannot get feedback from his 
   attempts.</p>
<p>But it is the third point that is the
   actual protection, and that we will look a little closer at. The procedure <b>search_orders</b> above should be coded as:</p>
<pre>CREATE PROCEDURE search_orders @custid   nchar(5) = NULL,
                               @shipname nvarchar(40) = NULL AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT OrderID, OrderDate, CustomerID, ShipName ' +
              ' FROM dbo.Orders WHERE 1 = 1 '
IF @custid IS NOT NULL
   SELECT @sql = @sql + ' AND CustomerID LIKE @custid
IF @shipname IS NOT NULL
   SELECT @sql = @sql + ' AND ShipName LIKE @shipname
EXEC sp_executesql @sql, N'@custid nchar(5), @shipname nvarchar(40)',
                   @custid, @shipname</pre>
<p>Since the <small class="allcaps">SQL</small> string does include any user input, there is 
   <i><b>no</b></i> opening for <small class="allcaps">SQL</small>
   injection. It's as simple as that. By the way, note that since we can include 
   parameters in the parameter list, even if they don't actually appear in the 
   <small class="allcaps">SQL</small> string, we don't need any complicated logic to build the parameter list, 
   but can keep it static. In the same vein, we can always pass all input 
   parameters to the <small class="allcaps">SQL</small> string.</p>
<p>As you may recall, you cannot pass everything as parameters to dynamic <small class="allcaps">SQL</small>,
   for instance table and column names. In this case you must enclose all such 
   object names in <nobr><b>quotename()</b></nobr>, that I will return to in the section <i>
   <a href="#good_practices">Good Coding Practices and Tips for Dynamic <small class="allcaps">SQL</small></a></i>.</p>
<p>The example above was for dynamic <small class="allcaps">SQL</small> in a <small class="allcaps"><nobr>T-SQL</nobr></small> stored procedure. The same advice
   applies to <small class="allcaps">SQL</small> generated in client code or in a <small class="allcaps">CLR</small> stored procedure. Since
   this is so important, here is an example of coding the above in VB6 and <small class="allcaps">ADO</small>:</p>
<pre>Set cmd = CreateObject("ADODB.Command")
Set cmd.ActiveConnection = cnn

cmd.CommandType = adCmdText
cmd.CommandText = " SELECT OrderID, OrderDate, CustomerID, ShipName " &amp; _
                  " FROM dbo.Orders WHERE 1 = 1 "
If custid &lt;&gt; "" Then
   cmd.CommandText = cmd.CommandText &amp; " AND CustomerID LIKE ? "
   cmd.Parameters.Append
      cmd.CreateParameter("@custid", adWChar, adParamInput, 5, custid)
End If

If shipname &lt;&gt; "" Then
   cmd.CommandText = cmd.CommandText &amp; " AND ShipName LIKE ? "
   cmd.Parameters.Append cmd.CreateParameter("@shipname", _
                         adVarWChar, adParamInput, 40, shipname)
End If

Set rs = cmd.Execute</pre>
<p>Since the main focus of this text is dynamic <small class="allcaps">SQL</small> in <small class="allcaps"><nobr>T-SQL</nobr></small> procedures, I will
   explain this example only briefly. In <small class="allcaps">ADO</small> you use <code>?</code> as a parameter
   marker, and you can only pass parameters that
   actually appear in the <small class="allcaps">SQL</small> string. (If you 
   specify too many parameters, you will get a completely incomprehensible error 
   message.) If you use the <small class="allcaps">SQL</small> Profiler to see what <small class="allcaps">ADO</small>
   sends to <small class="allcaps">SQL</small> Server, you will find that it invokes – <b>sp_executesql</b>.</p>
<p>Protection against <small class="allcaps">SQL</small> injection is not the only advantage of using
   parameterised queries. In the section <i><a href="#queryplans">Caching Query
   Plans</a></i>, we will look more in detail on parameterised queries and at a
   second very important reason to use them. This section also includes an example of composing and sending a parameterised <small class="allcaps">SQL</small> statement for SqlClient
   in VB .Net.</p>
<p>You may think that an even better protection against <small class="allcaps">SQL</small> injection is to use
   stored procedures with static <small class="allcaps">SQL</small> only. Yes, this is true, <b>
   <i>but</i>!</b> It
   depends on how you call your stored procedures from the client. If you
   compose an <small class="allcaps">EXEC</small> command into which you interpolate the input values, you are
   back on square one and you are as open to <small class="allcaps">SQL</small> injection as ever. 
   In <small class="allcaps">ADO</small>, you need to call
   your procedure with the command type <b>adCmdStoredProc</b> and use <b>.CreateParameter</b> to specify the parameters. By specifying <b>adCmdStoredProc</b>, you call the stored procedure through <small class="allcaps">RPC</small>, <i>
   Remote Procedure Call</i>, which not only protects you against <small class="allcaps">SQL</small> 
   injection, but it is also more efficient. Similar measures apply to other client APIs; 
   all APIs I know of supply a way to call a stored procedure through <small class="allcaps">RPC</small>.</p>
<h2><a name="storedprocedures">Dynamic SQL and Stored Procedures</a></h2>
<p>In the <a href="#forks">introduction</a>, I presented various strategies for
   data-access for an application, and I said that in many shops all data access
   is through stored procedures. In this section, I will look a little closer at
   the advantages with using stored procedures over sending <small class="allcaps">SQL</small> statements from
   the client. I will also look at what happens when you use dynamic <small class="allcaps">SQL</small> in a 
   stored procedure, and show that you lose some of the advantages with stored 
   procedures, whereas other are unaffected.</p>
<h3><a name="permissions">The Permission System</a></h3>
<p>Historically, using stored procedures has been <b>the</b> way to give users
   access to data. In a locked-down database, users do not have permissions to
   access tables directly. Instead, the application performs all
   access through stored procedures that retrieve and update data in a
   controlled way, so that users only get to see data they have access to, and
   they cannot perform updates that violate business rules. This works as long as the
   procedure and the tables have the same owner, typically <b>dbo</b> (the
   database owner), through a mechanism known as <i>ownership chaining</i>.</p>
<p>As I have already mentioned, <i><b>ownership chaining does not work when you
   use dynamic <small class="allcaps">SQL</small></b></i>. The reason for this is very simple: the block of
   dynamic <small class="allcaps">SQL</small> is not a procedure and does not have any owner. 
   Thus the chain
   is broken.</p>
<h4>SQL 2005</h4>
<p>In <small class="allcaps">SQL</small>&nbsp;2005 this can be addressed by signing a procedure that uses dynamic 
   <small class="allcaps">SQL</small> with a certificate. You associate the certificate with a user, and grant 
   that user (which is a user that cannot log in) the rights needed for the 
   dynamic <small class="allcaps">SQL</small> to execute successfully. A second method in <small class="allcaps">SQL</small>&nbsp;2005 is to use 
   the <small class="allcaps">EXECUTE AS</small> clause to impersonate a user that has been granted the 
   necessary permissions. This method is easier to use, but has side effects 
   that can have unacceptable consequences for auditing, row-level security 
   schemes and system monitoring. For this reason, my strong recommendation is 
   to use certificates.</p>
<p>Describing these methods more closely, would take up too much space here. 
   Instead I've written a separate article about them, <a href="http://www.sommarskog.se/grantperm.html"><i>Giving Permissions through Stored
   Procedures</i></a>, where I discusses both certificates and impersonation in 
   detail, and I also take a closer look on ownership chaining. </p>
<p>If you write <small class="allcaps">CLR</small> procedures that perform data access, the same is true 
   for them.
   Ownership chaining never applies since all data access in a <small class="allcaps">CLR</small> procedure is 
   through dynamic <small class="allcaps">SQL.</small> But you can use certificates or
   impersonation to avoid having to give users direct permissions on the
   tables.</p>
<h4>SQL 2000 and earlier</h4>
<p>On <small class="allcaps">SQL</small>&nbsp;2000 there is <i><b>no way</b></i> 
   to combine dynamic <small class="allcaps">SQL</small> with the encapsulation of permissions that you can get 
   through stored procedures. Any use of dynamic
   <small class="allcaps">SQL</small> requires that the users have direct permissions on the accessed tables. If your security
   scheme precludes giving users permissions to access tables directly, <i><b>you cannot
   use dynamic <small class="allcaps">SQL</small></b></i>. It is that plain and simple. Depending on the
   sensitivity of the data in the application, it may be acceptable to give the
   users <small class="allcaps">SELECT</small> permissions on the tables (or on some tables) to permit the use
   of dynamic <small class="allcaps">SQL</small>. I strongly recommend against granting users <small class="allcaps">INSERT, UPDATE</small>
   and <small class="allcaps">DELETE</small> rights on tables only to permit dynamic <small class="allcaps">SQL 
   in some occasional procedure.</small></p>
<p>There are nevertheless two alternatives, application roles and "application 
   proxies", but they require you to change the application architecture, so it 
   is nothing you introduce at whim.</p>
<p>Application roles were introduced in <small class="allcaps">SQL</small>&nbsp;7. Users log into <small class="allcaps">SQL</small> Server but have no permissions on their own beyond
   the database access. Instead, the application activates the application role by
   sending a password somehow embedded into it, and this application
   role has permissions to read and update tables. With application roles, it
   does not really matter if you use stored procedures or not. The same is true
   for "application proxies" where the application authenticates the users outside <small class="allcaps">SQL</small> Server and logs into <small class="allcaps">SQL</small>
   Server on their behalf with a proxy login. This proxy login impersonates the users in <small class="allcaps">SQL</small> Server, and
   thus their permissions apply. However, since the users do not have any login, they cannot
   log into <small class="allcaps">SQL</small> Server outside the application. In <i><a href="http://www.sommarskog.se/grantperm.html">Giving Permissions...</a></i>,
   I discuss these two methods a little further.</p>
<p>For both ofr these methods, keep in mind about <small class="allcaps">SQL</small> injection, and don't grant your application role or the
   login-less users anything beyond <small class="allcaps">SELECT, INSERT, UPDATE</small> and <small class="allcaps">DELETE</small> permissions on tables.
   (And preferably only <small class="allcaps">SELECT</small>, and stick all updates into stored procedures 
   with static <small class="allcaps">SQL</small>).</p>
<h3><a name="queryplans">Caching Query Plans</a></h3>
<p>Every query you run in <small class="allcaps">SQL</small> Server requires a query plan. When you run a query
   the first time, <small class="allcaps">SQL</small> Server builds a query plan for it – or as the terminology
   goes – it <i>compiles</i> the query. <small class="allcaps">SQL</small> Server saves the plan in cache, and next time you run
   the query, the plan is reused. The query plan stays in cache
   until it's aged out because it has not been used for a while, or it is
   invalidated for some reason. (Why this happens falls outside the scope of
   this article.)</p>
<p>The reuse of cached query plans is very important for the performance
   of queries where the compilation time is in par with the execution time or
   exceeds it. If
   a query needs to run for four minutes, it does not matter much if the query
   is recompiled for an extra second each time. On the other hand, if the execution time of the
   query is 40&nbsp;ms but it takes one second to compile the query, there is a
   huge gain with the cached plan, particularly if the query is executed over and
   over again.</p>
<p>Up to <small class="allcaps">SQL</small>&nbsp;6.5 the only plans there were put 
   into the cache were plans for stored
   procedures. Loose batches of <small class="allcaps">SQL</small> were compiled each time. And since the
   query plan for dynamic <small class="allcaps">SQL</small> is not part of the stored procedure, that includes
   dynamic <small class="allcaps">SQL</small> as well. Thus in <small class="allcaps">SQL</small>&nbsp;6.5, the use of dynamic <small class="allcaps">SQL</small> nullified the
   benefit with stored procedures in this regard.</p>
<p>Starting with <small class="allcaps">SQL</small>&nbsp;7, <small class="allcaps">SQL</small> Server also caches the plans for bare statements
   sent from a client or generated through dynamic <small class="allcaps">SQL</small>. Say that you send this
   query from the client, or execute it with <small class="allcaps"><nobr>EXEC()</nobr></small>:</p>
<pre>SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)
FROM   Orders O
JOIN   [Order Details] OD ON O.OrderID = OD.OrderID
WHERE  O.OrderDate BETWEEN '19980201' AND '19980228'
  AND  EXISTS (SELECT *
               FROM   [Order Details] OD2
               WHERE  O.OrderID = OD2.OrderID
                  AND OD.ProductID = 76)
GROUP  BY O.OrderID</pre>
<p>The query returns the total order amount for the orders in February 1998 that
   contained the product <i>Lakkalikööri.</i> <small class="allcaps">SQL</small> Server will put 
   the plan into the cache,
   and next time you run this query, the plan will be reused. But only if it is exactly the same query. 
   Since the cache lookup is by a hash value computed from the query text, the cache is space- and case-sensitive. 
   Thus, if you add a
   single space somewhere, the plan is not reused. More importantly, it is not
   unlikely that next time you want to run the query for a different product, or a
   different period.</p>
<p>All this changes, if you instead use <b>sp_executesql</b> to run your query 
   with parameters:</p>
<pre>DECLARE @sql nvarchar(2000)
SELECT @sql = 'SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)
               FROM   <b>dbo</b>.Orders O
               JOIN   <b>dbo</b>.[Order Details] OD ON O.OrderID = OD.OrderID
               WHERE  O.OrderDate BETWEEN @from AND @to
                 AND  EXISTS (SELECT *
                              FROM   <b>dbo</b>.[Order Details] OD2
                              WHERE  O.OrderID = OD2.OrderID
                                AND  OD.ProductID = @prodid)
                GROUP  BY O.OrderID'
EXEC sp_executesql @sql, N'@from datetime, @to datetime, @prodid int',
                   '19980201', '19980228', 76</pre>
<p>The principle for cache lookup is the same as for a non-parameterised query:
   <small class="allcaps">SQL</small> Server hashes the query text and looks up the hash value in the cache,
   still in a case- and space-sensitive fashion. But since the parameter values 
   are
   not part of the query text, the same plan can be reused even when the input
   changes.</p>
<p>To make this really efficient there is one more thing you need to observe.
   Do you see that I've prefixed all tables in the query with <b>dbo</b>? There 
   is a very important reason for this. On <small class="allcaps">SQL</small>&nbsp;2000, 
   this is an absolute must for effecient use of the query-plan cache. If you leave out <b>dbo</b> from a single
   table, each user will get his own copy of the plan in the cache. This is
   because on <small class="allcaps">SQL</small>&nbsp;2000, each user has a default schema which is equal to the
   username. So when <b>user1</b> runs a query that goes "<small class="allcaps">SELECT ... FROM</small>
   Orders", <small class="allcaps">SQL</small> Server must first check if there is a table <b>user1.Orders</b>,
   before it looks for <b>dbo.Orders</b>. Since <b>user1.Orders</b> could appear
   on the scene at any time, <small class="allcaps">SQL</small> Server needs to have a separate plan for each user.</p>
<p>The recommendation to include <b>dbo</b> applies very much to <small class="allcaps">SQL</small>&nbsp;2005 as well, but 
   it is not an absolute must. This is because on <small class="allcaps">SQL</small>&nbsp;2005, owner and schema has 
   been separated from each other so that users can have <b>dbo</b> as their 
   default schema, in which case they can share a plan even when tables are not prefixed 
   with <b>dbo</b>. (Since only <b>Orders</b> will be unambiguous.) Note here that for 
   this to happen, users must have been created with the new command <small class="allcaps">CREATE USER</small>. 
   If you – or the <small class="allcaps">DBA</small> –
   use <b>sp_adduser</b> out of habit, users still have their own default
   schema, and the situation is the same as on <small class="allcaps">SQL</small>&nbsp;2000. 
   Thus, to be safe, always prefix your tables with <b>dbo</b> in your dynamic <small class="allcaps">SQL</small> on <small class="allcaps">SQL</small>&nbsp;2005 as 
   well. (Unless, of course, you are actually using different schemas and not 
   only the <b>dbo</b> schema, something which is a lot easier to do now. If you want to read more about owner/schema separation, there is a
   section on it in my article <i><a href="http://www.sommarskog.se/grantperm.html#ownerschema">Granting Permissions through
   Stored Procedures</a></i>.) </p>
<p>If you instead use stored procedures, it is not equally important to prefix
   tables with <b>dbo</b>. Microsoft still recommends that you do, but even if
   you don't, users with different default schema can share the same query
   plan.</p>
<p>From what I have said here, it follows that if you use dynamic <small class="allcaps">SQL</small> with
   <small class="allcaps"><nobr>EXEC()</nobr></small> you lose an important benefit of stored procedures 
   whereas with <b>sp_executesql</b> you don't. At least in
   theory. It's easy to forget that <b>dbo</b>, and if you leave it out in just a
   single place in the query, you will get as
   many entries in the cache for the query as there are users running it. Recall
   also that the cache is space-
   and case-sensitive, so if you generate the same query in several places, you
   may inadvertently have different spacing or inconsistent use of case.
   Also, since the cache lookup is by a hash value computed from the query text, I
   would assume that this is somewhat more expensive than looking up a stored
   procedure. In fact, under extreme circumstances, heavy use of dynamic <small class="allcaps">SQL</small>, can lead to serious
   performance degradation. Some of my <small class="allcaps">MVP</small> colleagues have observed systems with
   lots of memory (&gt;&nbsp;20&nbsp;GB) when the plan cache has been so filled with plans
   for <small class="allcaps">SQL</small> statements, that there have been hash collisions galore, and the
   cache lookup alone could take several seconds. Presumably, the applications in
   question either did not use parameterised queries at all, or they failed to
   prefix tables with <b>dbo</b>.</p>
<p>So far, I've only talked about dynamic <small class="allcaps">SQL</small> in stored procedures. But in this
   regard there is very little difference to <small class="allcaps">SQL</small> statements sent from
   the client, or <small class="allcaps">SQL</small> statements generated in <small class="allcaps">CLR</small> procedures. The same rules
   apply: unparameterised statements are cached but with little probability for
   reuse, whereas parameterised queries can be as efficient as stored
   procedures if you remember to always prefix the tables with <b>dbo</b>. (And still
   with the caveat that the cache lookup is space- and case-sensitive.) Most client APIs implement
   parameterised queries by calling <b>sp_executesql</b> under the covers.</p>
<p>In the section on <a href="#SQL_injection"> <small class="allcaps">SQL</small> Injection</a>, I included an example on how to do
   parameterised queries with <small class="allcaps">ADO</small> and VB6.
   Here is an example with VB .Net and SqlClient:</p>
<pre>cmd.CommandType = System.Data.CommandType.Text
cmd.CommandText = _
    " SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)" &amp; _
    " FROM   dbo.Orders O " &amp; _
    " JOIN   dbo.[Order Details] OD ON O.OrderID = OD.OrderID" &amp; _
    " WHERE  O.OrderDate BETWEEN @from AND @to" &amp; _
    "   AND  EXISTS (SELECT *" &amp; _
    "                FROM   dbo.[Order Details] OD2" &amp; _
    "                WHERE  O.OrderID = OD2.OrderID" &amp; _
    "                  AND  OD.ProductID = @prodid)" &amp; _
    " GROUP  BY O.OrderID"

cmd.Parameters.Add("@from", SqlDbType.Datetime)
cmd.Parameters("@from").Value = "1998-02-01"

cmd.Parameters.Add("@to", SqlDbType.Datetime)
cmd.Parameters("@to").Value = "1998-02-28"

cmd.Parameters.Add("@prodid", SqlDbType.Int)
cmd.Parameters("@prodid").Value = 76</pre>
<p>In difference to <small class="allcaps">ADO</small>, SqlClient uses names with @ for parameters. The syntax
   for defining parameters is similar to <small class="allcaps">ADO</small>, but not identical. This article is
   long enough, so I will not go into details on how the <b>Parameters</b>
   collection works. Instead, I refer you to <small class="allcaps">MSDN</small> where both SqlClient and <small class="allcaps">ADO</small>
   are documented in detail. Whatever client <small class="allcaps">API</small> you are using, 
   <i><b>please</b></i>
   learn how to use parameterised commands with it. Yes, there is a tone of
   desperation in my voice. I don't know how many posts I've seen on the
   newsgroups over the years where people build their <small class="allcaps">SQL</small> strings by
   interpolating the values from input fields into the <small class="allcaps">SQL</small> string, and thereby
   degrading the performance of their application, and worst of all opening
   their database to <small class="allcaps">SQL</small> injection.</p>
<p>... and just when you thought you were safe, I need to turn this
upside down. Recall what I said in the beginning of this section, that
if the query is going to run for four minutes, one second extra for
compilation is not a big deal. And if that recompilation slashes the
execution time from forty minutes to four, there is a huge gain. Most
queries benefit from cached parameterised plans, but not all do. Say
that you have a query where the user can ask for data for some time
span. If the user asks for a summary for a single day, there is a good
non-clustered index that can be used for a sub-second response time.
But if the request is for the entire year, the same index would be a
disaster, and a table scan is to prefer. On <small class="allcaps">SQL</small>&nbsp;2005 you can force a 
   query to be recompiled each
   time it is executed by adding <small class="allcaps">OPTION (RECOMPILE)</small> 
   to the end of the query, and thus you can still use <b>sp_executesql</b> to get the 
   best protection against <small class="allcaps">SQL</small> injection. On <small class="allcaps">SQL</small>&nbsp;2000 
   and earlier, it may in fact be better to interpolate critical parameters into the 
   query string when you need to force recompilation each time. </p>
<p>Finally, for the sake of completeness, I should mention that <small class="allcaps">SQL</small>
   Server is able to auto-parameterise queries. If you submit:</p>
<pre>SELECT OrderID, OrderDate FROM dbo.Orders WHERE CustomerID = N'ALFKI'</pre>
<p><small class="allcaps">SQL</small> Server may recast this as </p>
<pre>SELECT OrderID, OrderDate FROM dbo.Orders WHERE CustomerID = @P1</pre>
<p>so if next time you submit <small class="allcaps">BERGS</small> instead of <small class="allcaps">ALFKI</small>, the query plan will be reused.
   Auto-parameterisation mainly happens with very simple
   queries, and, it seems, with some inconsistency. There is absolutely no
   reason to rely on it. (But in the situation you really a want a new query
   plan each time, you may have to verify that it doesn't happen when you don't
   want to.)</p>
<h3><a name="networktraffic">Reducing Network Traffic</a></h3>

<p>Another advantage with stored procedures over <small class="allcaps">SQL</small>
sent from the client is that less bytes travel the network. Rather than
sending a 50-line query over the network, you only need to pass the
name of a stored procedure and a few parameters. This gets more
significant if the computation requires several queries, possibly with
logic in between. If all logic is outside the database, this could mean
that data has to travel up to the client, only to travel back in the
next moment. With stored procedures you can use temp tables to hold
intermediate results. (You can use temp tables from outer layers as
well, although it may require some careful use of your client <small class="allcaps">API</small>.)</p>
<p>In this case, the dividing line goes between sending <small class="allcaps">SQL</small> from the client or
   running stored procedures. If the stored procedures use static <small class="allcaps">SQL</small> only, or
   invoke dynamic <small class="allcaps">SQL</small> does not matter, nor does it matter if it is a <small class="allcaps">CLR</small> procedure.
   You still get the gains of reduced network traffic.</p>
<h3><a name="encapsulation">Encapsulating Logic</a></h3>

<p>This is not a question of security or performance, but one of
   good programming practice and modularising your code. By using stored procedures, you don't have to bog down
your client code with the construction of <small class="allcaps">SQL</small> statements. Then again, it depends
   a little on what you put into those stored procedure. Myself, I am of the
   school that the business logic should be where the data is, and in this case
   there is no dispute that you should use stored procedures to encapsulate your
   logic.</p>
<p>But there are also people
   who prefer to see the database as a unintelligent container of data, and who
   prefer to have the business logic
   elsewhere. In this case, the arguments for using stored procedures
   for encapsulation may not be equally compelling. You could just as well employ careful programming practices in
   your client language and send <small class="allcaps">SQL</small> strings.</p>
<p>Nothing of this changes if you use dynamic <small class="allcaps">SQL</small> in your stored procedures. The
   stored procedure is still a container for some piece of logic, and how it
   looks on the inside does not matter. I'm here assuming that most of your
   procedures use static <small class="allcaps">SQL</small> only. If all your stored procedures
   generate dynamic <small class="allcaps">SQL</small>,
then you are probably better off in this regard to do it all in client
code. Then again, sometimes there is no other application than Query
Analyzer or <small class="allcaps">SQL</small> Server Management Studio. (Typically this would be
   tasks that are run by an admin.) In this case, the only container of logic
   available is stored procedures, and it's immaterial whether they use dynamic
   <small class="allcaps">SQL</small> or not.</p>
<h3><a name="trackability">Keeping Track of what Is Used</a></h3>

<p>In a complex system with hundreds of tables, you may need to know where a
   certain table or column is referenced, because you are considering changing
   or dropping it. If all access to tables is from static <small class="allcaps">SQL</small> in stored
   procedures, you may be able find all references by using the system
   stored procedure <b>sp_depends</b> or query a system table directly. (<b>sysdepends</b>
   in <small class="allcaps">SQL</small>&nbsp;2000, <b>sys.sql_dependencies</b> in <small class="allcaps">SQL</small>&nbsp;2005.) I say may, because it is very difficult to maintain complete dependency
   information in <small class="allcaps">SQL</small> Server. If you drop and recreate a table, all dependency
   information for the table is lost. What I do myself is to regularly build an empty database
   from our version-control system, and since our build tool
   loads all tables before any stored procedure or trigger, I know that I can
   trust the dependency information in that database.</p>
<p>If you throw dynamic <small class="allcaps">SQL</small> into the mix – be that <small class="allcaps">SQL</small> sent from client,
   dynamic <small class="allcaps">SQL</small> in <small class="allcaps"><nobr>T-SQL</nobr></small> procedures, or <small class="allcaps">SQL</small> generated by <small class="allcaps">CLR</small> stored procedures
   - you lose this opportunity. The alternative is to employ brute-force search,
   and if the construction of dynamic <small class="allcaps">SQL</small> is confined to some well-defined set
   of modules, this may work. If not, you may end up with a database where no
   one ever dares to drop or change a column or a table, and which eventually
   becomes unbearable complex and inefficient because of all the legacy baggage
   it's carrying around.</p>
<p>While the main dividing line here is between static <small class="allcaps">SQL</small> and any form of
   dynamic <small class="allcaps">SQL</small>, dynamic <small class="allcaps">SQL</small> in <small class="allcaps"><nobr>T-SQL</nobr></small> stored procedures is probably the least
   harmful, as there is less code to search. In <small class="allcaps">SQL</small>&nbsp;2005, you can even search
   the column <b>sys.sql_modules.definition</b> using <small class="allcaps">SQL</small>. (And in <small class="allcaps">SQL</small>&nbsp;2000 you
   can search <b>syscomments</b>, but as the procedure text there is chopped into
   4000-char slices, this is less reliable.)</p>
<p>In any case, an occasional stored procedure that uses dynamic <small class="allcaps">SQL</small> is not
   likely cause the Armageddon I pictured above. But it is
   a good argument for being restrictive with dynamic <small class="allcaps">SQL</small> in any form.</p>
<h3><a name="easiness">Easiness of Writing SQL Code</a></h3>
<p>One distinct advantage of writing stored <small class="allcaps"><nobr>T-SQL</nobr></small> procedures is that you get a
   syntax check directly. With dynamic <small class="allcaps">SQL</small>, a trivial syntax error may not show up
   until run time. Even if you test your code carefully, there may be some query, or
   some variation of a query, that is only run in odd cases and not covered in
   your test suite. </p>
<p>It has to be admitted that the strength of this argument is somewhat reduced by the fact
   that <small class="allcaps"><nobr>T-SQL</nobr></small> is not too industrious on reporting semantic errors. 
   Because of deferred name resolution, <small class="allcaps">SQL</small> Server will not examine queries in 
   stored procedures, where one or more tables are missing, be that misspellings 
   or temp tables created within the procedure. Nevertheless, <small class="allcaps">SQL</small> Server 
   does report sufficiently many errors, for this to be a very important reason 
   to use stored procedures.</p>
<p>Another side of this coin is that when you write dynamic <small class="allcaps">SQL</small>, you embed the
   <small class="allcaps">SQL</small> code into strings, which makes programming far more complex. Your <small class="allcaps">SQL</small>
   code is a string delimited by single quotes(<code>'</code>), and this string
   may include strings itself, and to include a single quote into the string you
   need to double it. You can easily get lost in a maze of quotes if you don't
   watch out. (In the section <i><a href="#good_practices">Good Coding Practices
   and Tips for Dynamic <small class="allcaps">SQL</small></a></i>, we will look a little closer 
   on how to deal
   with this problem.) The most commonly used client languages with <small class="allcaps"><nobr>T-SQL</nobr></small> -
   Visual Basic, <small class="allcaps">C#, C</small>++, VBScript – all use the double quote (<code>"</code>)
   as their string delimiter, so dynamic <small class="allcaps">SQL</small> in client code or <small class="allcaps">CLR</small> stored
   procedures is less prone to that particular problem. Then again, in VB you
   don't have multi-line strings, so at the end of each line you have to have a double
   quote, an ampersand and an underscore for continuation. It sure does not
   serve to make coding easier. You are relieved from all this hassle, if you 
   use stored procedures with static <small class="allcaps">SQL</small> only.</p>
<h3><a name="supportability">Addressing Bugs and Problems</a></h3>
<p>Somewhat surprisingly, one of the strongest arguments for stored procedures today may
   be
 that they permit you to quickly address bugs and performance problems in the
 application.</p>
<p>Say that you generate <small class="allcaps">SQL</small> statements in your application, and that there is
 an error in it. Or that it simply performs unbearably slow. To fix it, you need to
 build a new executable or <small class="allcaps">DLL</small>, which is likely to contain other code that also
   has changed since the module was shipped. This
 means that before the fix can be put into production, the module will have to go
 through QA and testing.</p>
<p>On the other hand, if the problem is in a stored procedure, and the fix is
 trivial, you may be able to deploy a fix into production within an hour after
 the problem was reported. </p>
<p>This difference is even more emphasised, if you are an <small class="allcaps">ISV</small> and you ship a
   product that the customer is supposed administer himself. If your application
   uses stored procedures, a <small class="allcaps">DBA</small> may be able to address problems directly
   without opening support cases. For instance, if a procedure runs unacceptably
   slow, he may be able to fix that by adding an index hint. In contrast,
   with an application that generates <small class="allcaps">SQL</small> in the
 client, his hands will be tied. Of course, as an <small class="allcaps">ISV</small> you may not want your
 customers to poke around in your code, even less to change it. You may also prefer
   to ship your procedures <small class="allcaps">WITH ENCRYPTION</small> to protect
   your intellectual property, but this is best controlled
 through license agreements. (If you encrypt your procedures, the <small class="allcaps">DBA</small> can still
   change them, as long as he is able to find a way to decrypt them. Which any
   <small class="allcaps">DBA</small> that knows how to use Google can do.) </p>
<p>In this case, it does not matter whether the stored procedure uses static <small class="allcaps">SQL</small>
   only, or if it also uses dynamic <small class="allcaps">SQL</small>. For <small class="allcaps">CLR</small> procedures it depends on many objects 
   you have in your assemblies. If you have one assembly per object, installing a new version of a <small class="allcaps">CLR</small> procedure
   is as simple as replacing a <small class="allcaps"><nobr>T-SQL</nobr></small> procedure.</p>
<p>(I should add that <small class="allcaps">SQL</small>&nbsp;2005 offers a new feature that permits the <small class="allcaps">DBA</small> to
   change the plan for a query without altering the code, by adding a <i>plan guide</i>.
   This is quite an advanced feature, and I refer to Books Online for details.)</p>
<h2><a name="good_practices">Good Coding Practices and Tips for Dynamic SQL</a></h2>
<p>Writing
 dynamic <small class="allcaps">SQL</small> is a task that requires discipline to avoid that you lose control
   over your code. If you
   just go ahead, your code can become very messy, and be difficult to read, troubleshoot
   and maintain. In this section, we will look at how to avoid this. I will also
   discuss some special cases: how you can use <b>sp_executesql</b> for input longer
   than 4000 chars in <small class="allcaps">SQL</small>&nbsp;2000, and how to use dynamic <small class="allcaps">SQL</small> with cursors, and the
   combination of dynamic <small class="allcaps">SQL</small> and user-defined functions.</p>
<h3><a name="debugprints">Use Debug Prints!</a></h3>
<p>When you write a stored procedure that generates dynamic <small class="allcaps">SQL</small>, you should
   always include a @debug parameter:</p>
<pre>CREATE PROCEDURE dynsql_sp @par1 int,
                           ...
                           @debug bit = 0 AS
...
IF @debug = 1 PRINT @sql</pre>
<p>When you get a syntax error from the dynamic <small class="allcaps">SQL</small>, it can be very confusing, and
   you may not even discern where it comes from. And even when you do, it can be
   very difficult to spot the error only by looking at the code that constructs the <small class="allcaps">SQL</small>.
   Once the <small class="allcaps">SQL</small> code is slapped in your face, the error is much more likely to be apparent to you.
   So always include a @debug parameter and a <small class="allcaps">PRINT</small>!</p>
<h3><a name="nestedstrings">Nested Strings</a></h3>
<p>As I've already mentioned, one problem with dynamic <small class="allcaps">SQL</small> is that you often need to deal with nested
   string delimiters. For instance, in the beginning of this article, I showed
   you the procedure <b>general_select2</b>. Here it is again:</p>
<pre>CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>(Again, I like to emphasise that this sort of procedure is poor use of
   dynamic <small class="allcaps">SQL</small>.)</p>
<p>
<small class="allcaps">SQL</small> is one of those language where the method to include a string
delimiter itself in a string literal is to double it. So those four consecutive
single quotes <code>('''')</code> is a string literal with the value of a one
single quote (<code>'</code>).
This is a fairly simple example, it can get a lot worse. If you work with
dynamic <small class="allcaps">SQL</small>, you must learn to master nested strings. Obviously, in this case you
can easily escape the mess by using <b>sp_executesql</b> instead – yet another reason
to use parameterised statements. However, there are situations when you need to
deal with nested quotes even with <b>sp_executesql</b>. For instance, earlier in this
article, I had this code:</p>
<pre>N' WHERE LastUpdated BETWEEN @fromdate AND '
N'                           coalesce(@todate, ''99991231'')'</pre>
<p>We will look at some tips of dealing with nested strings later in this
   section.</p>
<h3><a name="formatting">Spacing and Formatting</a></h3>
<p>Another thing to be careful with is the spacing as you concatenate the parts 
   of a query.
   Here is an example where it goes wrong:</p>
<pre>EXEC('SELECT col1, col2, col3
      FROM' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>
See that there is a space missing after <small class="allcaps">FROM</small>? When you compile the stored procedure
you will get no error, but when you run it, you will be told that the columns <i>
keycol</i>, <i>col1, col2, col3</i> are missing. And since you know that the
table you passed to the procedure has these columns you will be mighty confused. But this is
the actual code generated, assuming the parameters <b>foo</b> and <b>abc</b>:</p>
<pre>SELECT col1, col2, col3
    FROMfoo
    WHERE keycol = 'abc'</pre>
This is not a syntax error, because <code>FROMfoo</code> is a column alias to <i>col3</i>.
And, yes, it's legal to use a <small class="allcaps">WHERE</small> clause, even if there is no <small class="allcaps">FROM</small> clause. But
since the columns cannot exist out of the blue, you get an error for that.<p>
   This is also a good example why you should use debug prints. If the code 
   looks like this:</p>
<pre>SELECT @sql =' SELECT col1, col2, col3
               FROM' + @tblname + '
               WHERE keycol = ''' + @key + ''''
IF @debug = 1 THEN PRINT @sql
EXEC(@sql)</pre>
<p>It would be much easier to find the error by running the procedure with
   @debug = 1. (Obviously, had we included the <b>dbo</b> prefix, this error
   could not occur at all.)</p>
<p>Overall, good formatting is essential when working with dynamic <small class="allcaps">SQL</small>. Try to
   write the query as you would have written it in static <small class="allcaps">SQL</small>, and then add the
   string delimiters outside of that. <small class="allcaps"><nobr>T-SQL</nobr></small> permits you to embed newlines in
   string literals (as testified by the example above), so in difference to VB,
   you don't need a string delimiter on each line. An advantage of this is that
   your debug <small class="allcaps">PRINT</small> is easier to read, and in case of a syntax error, the line
   number in the error message may guide you.</p>
<p>You may prefer, though, to
   have a string terminator on each line. A tip in such case is to do something
   like this:</p>
<pre>EXEC(' SELECT col1, col2, col3 ' +
     ' FROM ' + @tblname +
     ' WHERE keycol = ''' + @key + '''')</pre>
<p>As you see, I have a space after the opening single quote on each line to avoid syntax problems due to missing spaces.</p>
<h3><a name="objectnames">Dealing with Dynamic Table and Column Names</a></h3>
<p>Passing table and column names as parameters to a procedure with dynamic <small class="allcaps">SQL</small>
   is rarely a good idea for application code. (It can make perfectly sense for
   admin tasks). As I've said, you cannot pass a table or a column name as a
   parameter to <b>sp_executesql</b>, but you must interpolate it into the <small class="allcaps">SQL</small> string.
   Still you should protect it against <small class="allcaps">SQL</small> 
   injection, as a matter of routine. It could be that bad it comes from user 
   input. </p>
<p>To this end, you should use the built-in function <b><nobr>quotename()</nobr></b> (added in
   <small class="allcaps">SQL</small>&nbsp;7). <nobr><b>quotename()</b></nobr> takes two parameters: the first is a string, and the second
   is a pair of delimiters to wrap the string in. The default for the second
   parameter is []. Thus, <code>quotename('Orders')</code> returns <code>
   [Orders]</code>. <nobr><b>quotename()</b></nobr> takes care of nested delimiters, so if you have
   a really crazy table name like <b>Left]Bracket</b>, <nobr><b>quotename()</b></nobr> will
   return <code><nobr>[Left]]Bracket]</nobr></code>.</p>
<p>Note that when you work with names with several components, each component 
   should be quoted separately. <code><nobr>quotename('dbo.Orders')</nobr></code> returns
   <code><nobr>[dbo.Orders]</nobr></code>, but that is a table in an unknown
   schema of which the first four characters are <b>d</b>, <b>b</b>, <b>o</b> and
   dot. As long as you only work with the <b>dbo</b> schema, best practice is to
   add <b>dbo</b> in the dynamic <small class="allcaps">SQL</small> and only pass the table name. If you work
   with different schemas, pass the schema as a separate parameter. (Although
   you could use the built-in function <nobr><b>parsename()</b></nobr> to split up a 
   @tblname
   parameter in parts.)</p>
<p>While <b>general_select</b> still is a poor idea as a stored procedure, here 
   is nevertheless a version that summarises some good coding
   virtues for dynamic <small class="allcaps">SQL</small>:</p>
<pre>CREATE PROCEDURE general_select @tblname nvarchar(128),
                                @key     varchar(10),
                                @debug   bit = 0 AS
DECLARE @sql nvarchar(4000)
SET @sql = 'SELECT col1, col2, col3
            FROM dbo.' + quotename(@tblname) + '
            WHERE keycol = @key'
IF @debug = 1 PRINT @sql
EXEC sp_executesql @sql, N'@key varchar(10)', @key = @key</pre>
<ul>
   <li>I'm using <b>sp_executesql</b> rather than <small class="allcaps"><nobr>EXEC()</nobr></small>.</li>
   <li>I'm prefixing the table name with <b>dbo</b>.</li>
   <li>I'm wrapping @tblname in <b><nobr>quotename()</nobr></b>.</li>
   <li>There is a @debug parameter.</li>
   </ul>
<h3><a name="quotestring">Quotename, Nested Strings and Quotestring</a></h3>
<p>
The main purpose of <nobr><b>quotename()</b></nobr> is to quote object names, which is why the
default for the second parameter is brackets. But you can specify other
delimiters as well, including single quotes, which means that any single quote
in the input is doubled. Thus, if you for some reason prefer to use
     <small class="allcaps"><nobr>EXEC()</nobr></small>, you can use <b><nobr>quotename()</nobr></b> to protect yourself against <small class="allcaps">SQL</small>
     injection by help of this function. Here is an example.</p>
<pre>IF @custname IS NOT NULL
   SELECT @sql = @sql + ' AND custname = ' + quotename(@custname, '''')</pre>
<p>Say that @custname has the value <i>D'Artagnan</i>. This part of the dynamic <small class="allcaps">SQL</small>
   becomes:</p>
<pre>AND custname = 'D''Artagnan'</pre>
<p>There is a limitation with <b><nobr>quotename()</nobr></b>: its input parameter
     is <b>nvarchar(128)</b>, so it does not handle long strings. A remedy is this user-defined function: </p>
<pre>CREATE FUNCTION quotestring(@str nvarchar(1998)) RETURNS nvarchar(4000) AS
BEGIN
   DECLARE @ret nvarchar(4000),
           @sq  char(1)
   SELECT @sq = ''''
   SELECT @ret = replace(@str, @sq, @sq + @sq)
   RETURN(@sq + @ret + @sq)
END</pre>
<p>This version is for <small class="allcaps">SQL</small>&nbsp;2000. On <small class="allcaps">SQL</small>&nbsp;2005 replace 1998 and 4000 with <small class="allcaps">MAX, 
   so that it works for any string length. </small>Here is an example of using this function:</p>
<pre>IF @custname IS NOT NULL
   SELECT @sql = @sql + ' AND custname = ' + dbo.quotestring(@custname)</pre>
<p>
The result is the same as above.</p>
<p>
On <small class="allcaps">SQL</small>&nbsp;7, you would have to implement <b>quotestring</b> as a stored procedure.
<small class="allcaps">SQL</small>&nbsp;6.5 does not have <b><nobr>replace()</nobr></b>, so you are a bit out of luck there. </p>
<p>
So with <nobr><b>quotename()</b></nobr> and <nobr><b>quotestring()</b></nobr>, 
do we have as good protection against <small class="allcaps">SQL</small>
injection as we have with parameterised commands? Maybe. I don't know of any way to
inject <small class="allcaps">SQL</small> that slips through <nobr><b>quotename()</b></nobr> or <nobr><b>quotestring()</b></nobr>. Nevertheless, you
are interpolating user input into the <small class="allcaps">SQL</small> string, whereas with parameterised
commands, you don't.</p>
<p>
(I
should add that I got the suggestion to use <b><nobr>quotename()</nobr></b> or a user-defined
function from <small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Steve Kass.)</p>
<h3><a name="QUOTED_IDENTIFIER">QUOTED_IDENTIFIER</a></h3>
<p>Another alternative to
   escape the mess of nested quotes, is make use
   of the fact that <small class="allcaps"><nobr>T-SQL</nobr></small> actually has two string delimiters. To wit, if the
   setting <small class="allcaps">QUOTED_IDENTIFIER</small> is <small class="allcaps">OFF</small>, you can also use double quotes(<code>"</code>)
   as a string delimiter. The default
   for this setting depends on context, but the preferred setting is 
   <small class="allcaps">ON</small>, and it
   must be <small class="allcaps">ON</small> in order to use XQuery, indexed views and indexes on computed columns.
   Thus, this is not a first-rate alternative, but if you are aware of the caveats,
   you can do this:</p>
<pre>CREATE PROCEDURE general_select @tblname nvarchar(127),
                                @key     key_type,
                                @debug   bit = 0 AS
DECLARE @sql nvarchar(4000)

SET @sql = 'SET QUOTED_IDENTIFIER OFF
            SELECT col1, col2, col3
            FROM dbo.' + quotename(@tblname) + '
            WHERE keycol = "' + @key + '"'
IF @debug = 1 PRINT @sql
EXEC(@sql)</pre>

<p>Since there are two different quote characters, the code is much easier to
   read. The single quotes are for the <small class="allcaps">SQL</small> string and the double quotes 
   are for
   the embedded string literals. </p>
<p>All and all, this is an inferior method to both <b>sp_executesql</b> and <b><nobr>quotestring()</nobr></b>, since you are not protected against <small class="allcaps">SQL</small> injection
   (what if @key includes a double quote?). But it
   would be OK to do for some sysadmin task (where <small class="allcaps">SQL</small> injection is not likely
   to be an issue), and it may be the best way to go on <small class="allcaps">SQL</small>&nbsp;6.5. </p>
<h3><a name="sp_executesqlong">sp_executesql and Long SQL Strings in SQL 2000</a></h3>
<p>There is a limitation with <b>sp_executesql</b> on <small class="allcaps">SQL</small>&nbsp;2000
   and <small class="allcaps">SQL</small>&nbsp;7, since you cannot use longer <small class="allcaps">SQL</small> 
   strings than 4000 characters. (On <small class="allcaps">SQL</small>&nbsp;2005, 
   use <b>nvarchar(<small class="allcaps">MAX</small>)</b> to avoid this 
   problem.) If you
   want to use <b>sp_executesql</b> despite you query string is longer, because
   you want to make use of parameterised query plans, there is actually a
   workaround. To wit, you can wrap <b>sp_executesql</b> in <small class="allcaps"><nobr>EXEC()</nobr></small>:</p>
<pre>DECLARE @sql1 nvarchar(4000),
        @sql2 nvarchar(4000),
        @state char(2)
SELECT @state = 'CA'
SELECT @sql1 = N'SELECT COUNT(*)'
SELECT @sql2 = N'FROM dbo.authors WHERE state = @state'
EXEC('EXEC sp_executesql N''' + @sql1 + @sql2 + ''',
                         N''@state char(2)'',
                         @state = ''' + @state + '''')</pre>
<p>This works, because the @stmt parameter to <b>sp_executesql</b> is <b>ntext</b>, so by
   itself, it does not have any limitation in size.</p>
<p>You can even use output parameters by using
   <a href="http://www.sommarskog.se/share_data.html#INSERTEXEC"><small class="allcaps">INSERT-EXEC</small></a>, as
   in this example:</p>
<pre>CREATE TABLE #result (cnt int NOT NULL)
DECLARE @sql1  nvarchar(4000),
        @sql2  nvarchar(4000),
        @state char(2),
        @mycnt int
SELECT @state = 'CA'
SELECT @sql1 = N'SELECT @cnt = COUNT(*)'
SELECT @sql2 = N'FROM dbo.authors WHERE state = @state'
INSERT #result (cnt)
   EXEC('DECLARE @cnt int
         EXEC sp_executesql N''' + @sql1 + @sql2 + ''',
                            N''@state char(2),
                               @cnt   int OUTPUT'',
                            @state = ''' + @state + ''',
                            @cnt = @cnt OUTPUT
         SELECT @cnt')
SELECT @mycnt = cnt FROM #result</pre>
<p>You have my understanding if you think this is too messy to be worth it.</p>
<h3><a name="UDF">Dynamic SQL in User-Defined Functions</a></h3>
<p>This very simple: you <i><b>cannot</b></i> use dynamic <small class="allcaps">SQL</small> from used-defined functions
   written in <small class="allcaps"><nobr>T-SQL</nobr></small>. This is because you are not permitted do anything in a <small class="allcaps">UDF</small>
   that could change the database state (as the <small class="allcaps">UDF</small> may be invoked as part of a
 query). Since you can do anything from dynamic <small class="allcaps">SQL</small>, including updates, it is
 obvious why dynamic <small class="allcaps">SQL</small> is not permitted.</p>
<p>I've seen more than one post on the newsgroups where people have
   been banging their head against this. But if you want to use dynamic <small class="allcaps">SQL</small> in a
 <small class="allcaps">UDF</small>, back out
   and redo your design. You have hit a roadblock, and in <small class="allcaps">SQL</small>&nbsp;2000 there is no
   way out.</p>
<p>In <small class="allcaps">SQL</small>&nbsp;2005, you could implement your function as a <small class="allcaps">CLR</small> function. Recall that
   all data access from the <small class="allcaps">CLR</small> is dynamic <small class="allcaps">SQL.</small> (You are safe-guarded, so that if
   you perform an update operation from your function, you will get caught.) A
   word of warning though: data access from scalar UDFs can often give performance
   problems. If you say </p>
<pre>SELECT ... FROM tbl WHERE dbo.MyUdf(somecol) = @value</pre>
<p>and <b>MyUdf</b> performs data access, you have more or less created a hidden 
   cursor. </p>
<h3><a name="cursor0">Cursors and Dynamic SQL</a></h3>
<p>Not that cursors are something you should use very frequently, but people often
ask about using dynamic <small class="allcaps">SQL</small> with cursors, so I give an example for the sake
   of completeness. You cannot say <kbd>DECLARE CURSOR <nobr>EXEC()</nobr></kbd>; you have to put the
entire <small class="allcaps">DECLARE CURSOR</small> statement in dynamic <small class="allcaps">SQL</small>:</p>
<pre>SELECT @sql = 'DECLARE my_cur INSENSITIVE CURSOR FOR ' +
              'SELECT col1, col2, col3 FROM ' + @table
EXEC sp_executesql @sql</pre>
<p>You may be used to using the <small class="allcaps">LOCAL</small> keyword with your cursors. However, it is
   important to understand that you must use a global cursor, as a local cursor
   will disappear when the dynamic <small class="allcaps">SQL</small> exits. (Because, as you know by now, the 
   dynamic <small class="allcaps">SQL</small> is its own scope.) Once you have declared the
   cursor in this way, you can use the cursor in a normal fashion. You must be
   extra careful with error-handling though, so that you don't exit the
   procedure without deallocating the cursor. </p>
<p>There is however a way to use locally-scoped cursors with dynamic <small class="allcaps">SQL</small>.
   Anthony Faull pointed out to me that you can achieve this with cursor variables, as in this example:</p>
<pre>DECLARE @my_cur CURSOR
EXEC sp_executesql
     N'SET @my_cur = CURSOR STATIC FOR 
       SELECT name FROM dbo.sysobjects; 
       OPEN @my_cur',
     N'@my_cur cursor OUTPUT', @my_cur OUTPUT
FETCH NEXT FROM @my_cur</pre>
<p>
You refer to a cursor variable, just like named cursors, but there is an @ in front,
and, as you see from the example, you can pass them as a parameters. (I have to confess
I have never seen any use for cursor variables until Anthony Faull was kind to send
me this example.)</p>
<h2><a name="EXECatlinked"><nobr>EXEC()</nobr> at Linked Server</a></h2>
<p>A special feature added in <small class="allcaps">SQL</small>&nbsp;2005 is that you can use <small class="allcaps"><nobr>EXEC()</nobr></small> to run
   pass-through queries on a linked server. This could be another instance of
   <small class="allcaps">SQL</small> Server, but it could also be an Oracle server, an Access database, Active
   directory or whatever. The <small class="allcaps">SQL</small> could be a single query or a sequence of
   statements, and could it be composed dynamically or be entirely static. The syntax
   is simple, as seen by this example:</p>
<pre>EXEC('SELECT COUNT(*) FROM ' + @db + '.dbo.sysobjects') AT SQL2K</pre>
<p><small class="allcaps">SQL2K</small> is here a linked server that has been defined with <b>
   sp_addlinkedserver</b>.</p>
<p>There is one thing that you can do with <small class="allcaps"><nobr>EXEC()</nobr></small> at a linked server, that you
   cannot do with <small class="allcaps"><nobr>EXEC()</nobr></small> on a local server: you can use parameters, both for
   input and output. The confuse matters, you don't use parameters with names
   starting with @, instead you use question marks (<code>?</code>) as parameter
   holders. Say that you are on an <small class="allcaps">SQL</small>&nbsp;2005 box, and you are dying to know how
   many orders <small class="allcaps">VINET</small> had in the <b>Northwind</b> database. Unfortunately, <small class="allcaps">SQL</small>&nbsp;2005 does
   not ship with <b>Northwind</b>, but you have a linked server set up to an instance
   of <small class="allcaps">SQL</small>&nbsp;2000 with <b>Northwind</b>. You can run this:</p>
<pre>DECLARE @cnt int
EXEC('SELECT ? = COUNT(*) FROM Northwind.dbo.Orders WHERE CustomerID = ?',
      @cnt OUTPUT, N'VINET') AT SQL2K
SELECT @cnt</pre>
<p>Note here that the parameter values must appear in the order the parameter
   markers appear in the query. When passing a parameter, you can either specify a
   constant value or a variable. </p>
<p>You may ask why the inconsistency with a different parameter marker from
   <b>sp_executesql</b>? Recall that linked servers in <small class="allcaps">SQL</small> Server are always accessed
   through an <small class="allcaps">OLE DB</small> provider, and <small class="allcaps">OLE DB</small> uses <code>?</code> as
   the parameter marker, a convention inherited from <small class="allcaps">ODBC. OLE DB</small> translates
   that parameter marker as is appropriate for the data source on the other end.
   (Not all <small class="allcaps">RDBMS</small> use @ for variables.) </p>
<p>As with regular <small class="allcaps"><nobr>EXEC()</nobr></small>, you can specify <small class="allcaps">AS USER/LOGIN</small> to use impersonation:</p>
<pre>EXEC('SELECT COUNT(*) FROM ' + @db + '.dbo.sysobjects')
    AS USER = 'davidson' AT SQL2K</pre>
<p>This begs the question: is <b>davidson</b> here a local user or a remote
   user at <small class="allcaps">SQL2K</small>? Books Online is not very clear 
   about this, but I did some
   quick experimenting, and found that what you are impersonating is a local user or login,
   not a login on the remote server. (The login to use on the remote server can be
   defined with <b>sp_addlinkedsrvlogin</b>.)</p>
<h2><a name="Common_cases">Common Cases when to (Not) Use Dynamic SQL</a></h2>
<p>When you read the various newsgroups on <small class="allcaps">SQL</small> Server, there is almost every day
   someone who asks a question that is answered with <i>use dynamic <small class="allcaps">SQL</small></i> with a quick example 
   to illustrate, but ever so often the person answering forgets to tell
about the implications on permissions or <small class="allcaps">SQL</small> injection. On top of 
   that, far too
   many examples uses <small class="allcaps"><nobr>EXEC()</nobr></small> without any thought of query plans. And while many of these
   questions taken by the letter have no other answer than dynamic <small class="allcaps">SQL</small>, there is
   often a real business problem which has a completely different solution
   without dynamic <small class="allcaps">SQL</small> – and
   a much better one.</p>
<p>So, in this section I will explore some situations where you <i>could</i> use dynamic
<small class="allcaps">SQL</small>. You will see that sometimes dynamic <small class="allcaps">SQL</small> is a 
   good choice, but also that in many cases that it is an outright bad idea. </p>
<h3><a name="Dyn_table">SELECT * FROM @tablename</a></h3>
<p>A common question is why the following does not work: </p>
<pre>CREATE PROCEDURE my_proc @tablename sysname AS
   SELECT * FROM @tablename</pre>

<p>As we have seen, we can make this procedure work with help of dynamic <small class="allcaps">SQL</small>, but
   it should also be clear that we gain none of the advantages with generating
   that dynamic <small class="allcaps">SQL</small> in a stored procedure. You could just as well send the
   dynamic <small class="allcaps">SQL</small> from the client. So, OK: 1) if the
   <small class="allcaps">SQL</small> statement is very complex, you save some network 
   traffic and you do
   encapsulation. 2) As we have seen, on <small class="allcaps">SQL</small>&nbsp;2005 there are methods to deal with
   permissions. Nevertheless, this<b> is</b> a bad idea.<b> </b> </p>
<p> There seems to be several reasons why people want to parameterise the table
   name. One camp
   appears to be people who are new to <small class="allcaps">SQL</small> programming, but have experience 
   from other
languages such as <small class="allcaps">C++, VB</small> etc where parameterisation is a good thing. Parameterising
the table name to achieve generic code and to increase
maintainability seems like good programmer virtue. </p>
<p>But it is just that when it comes to database objects, the old truth does not
hold. In a proper database design, each table is unique, as it describes a
   unique entity. (Or at least it should!) Of course, it is not uncommon to end
   up with a dozen or more look-up tables that all have an id, a name
   column and some auditing columns. But they do describe different entities,
   and their semblance should be regarded as mere chance, and future
   requirements may make the tables more dissimilar.</p>
<p>Furthermore, when it comes to building a query plan, each table has its set 
   of statistics and
   presumptions that are by no means interchangeable, as far as <small class="allcaps">SQL</small>
Server is concerned. Finally, in a complex data model, it is important
to get a grip of what's being used. When you start to pass table and
column names as parameters, you definitely lose control.</p>
<p>So if you want to do the above (save the fact that <small class="allcaps">SELECT</small> * should not be
   used in production code), to save some typing, you are on the wrong path. It is
much better to write ten or twenty stored procedures, even if they are similar
to each other. </p>
<p>(If your <small class="allcaps">SQL</small> statements are complex, so that there actually is a considerable
   gain in maintainability to only have them in one place, despite different
   tables being used, you could consider using a
   pre-processor like the one in <small class="allcaps">C/C++</small>. You would still have one set of
   procedures per table, but the code would be in one single include file.)</p>
<h3><a name="Sales_yymm">SELECT * FROM sales + @yymm</a></h3>
<p>This is a variation of the previous case, where there is a suite of tables
   that actually do describe the same entity. All tables have the same columns, and the name includes some partitioning
   component, typically year and sometimes also month. New tables are created as
   a new year/month begins.</p>
<p>In this case, writing one stored procedure per table is not really feasible.
   Not the least, because the user may want to specify a date range for a search, so even
   with one procedure per table you would still need a dynamic dispatcher.</p>
<p>Now, let's make this very clear: this is a flawed
   table design. You should not have one <b>sales</b> table per month, you should
   have one single <b>sales</b> table, and the month that appear in the table
   name, should be the first column of the primary key in the united <b>sales</b> table. At least
   logically. Sometimes, when you have <b><i>huge</i></b> tables (say over 10 GB
   in size), partitioning can be a good idea, but you should do it right and use
   partitioned views, that we will look at in this section. I like
   to make the point that since <small class="allcaps">SQL</small> Server is a enterprise <small class="allcaps">RDBMS</small>, it can
   handle very large tables very efficiently, as long as you keep in mind that
   good indexing is essential. A few million rows is no cause for concern.</p>
<p>If you have a legacy application, it may be prohibitively
   expensive to make a redesign. Then again, the complexity of dynamic <small class="allcaps">SQL</small> also
   comes with a cost. Fortunately, there are alternatives. A simple approach is
   to define a view like this:</p>
<pre>CREATE VIEW sales AS
   SELECT year = '2006', * FROM dbo.sales2006
   UNION ALL
   SELECT year = '2005', * FROM dbo.sales2005
   UNION ALL
   ...  </pre>
<p>(For a view like this, <small class="allcaps">SELECT</small> * could be 
   considered OK.) Instead of composing
   the table name dynamically, you can now say:</p>
<pre>SELECT ... FROM sales WHERE year = '2006' AND ...</pre>
<p>Unfortunately, this view is not terribly efficient, as the query will access 
   all three tables. Furthermore, the view is not updateable. While this is a 
   partitioned view in some sense, the view does not fulfil the rules for partitioned views
   in the <small class="allcaps">SQL</small> Server sense. Such views can be very efficient, because for
   queries that include the partitioning column in the <small class="allcaps">WHERE</small> clause, <small class="allcaps">SQL</small> Server
   will only access the relevant table(s). And such a view is updatable, so you
   can insert data into it, and the data will end up in the right table. </p>
<p>Here is a
   quick example/demo on how to properly set up a partitioned view. Assume that
   as legacy of a poor design we have these three tables:</p>
<pre>SELECT * INTO Orders96 FROM Northwind..Orders WHERE year(OrderDate) = 1996
ALTER TABLE Orders96 ADD CONSTRAINT pk96 PRIMARY KEY (OrderID)

SELECT * INTO Orders97 FROM Northwind..Orders WHERE year(OrderDate) = 1997
ALTER TABLE Orders97 ADD CONSTRAINT pk97 PRIMARY KEY (OrderID)

SELECT * INTO Orders98 FROM Northwind..Orders WHERE year(OrderDate) = 1998
ALTER TABLE Orders98 ADD CONSTRAINT pk98 PRIMARY KEY (OrderID)</pre>
<p>First step is to a add <b>Year</b> column to each table. These columns need a
   default (so that processes that insert directly into these tables are
   unaffected) and a <small class="allcaps">CHECK</small> constraint. Here is how it looks for <b>Orders96</b>:</p>
<pre>ALTER TABLE Orders96 ADD Year char(4) NOT NULL
   CONSTRAINT def96 DEFAULT '1996'
   CONSTRAINT check96 CHECK (Year = '1996')</pre>
<p>This column must be the first column in the primary key, so we need to drop
   the current primary key and recreate it:</p>
<pre>ALTER TABLE Orders DROP CONSTRAINT pk96
ALTER TABLE Orders96 ADD CONSTRAINT u96 UNIQUE (Year, OrderID)</pre>
<p>Again, this must be performed for all three tables. Finally, you can create
   the view:</p>
<pre>CREATE VIEW Orders AS
   SELECT * FROM dbo.Orders96
   UNION ALL
   SELECT * FROM dbo.Orders97
   UNION ALL
   SELECT * FROM dbo.Orders98</pre>
<p>You now have a proper partitioned view that you can perform inserts and updates through. And if you run a query like:</p>
<pre>SELECT OrderID, OrderDate, EmployeeID
FROM   Orders
WHERE  Year = @year
  AND  CustomerID = N'BERGS'</pre>
<p><small class="allcaps">SQL</small> Server will at run-time only access the OrdersNN table that maps to
   @year. If you look at the query plan casually, it may seem that all three 
   tables are
   accessed, but if you check the <b>Filter</b> operators you will find something
   called <small class="allcaps">STARTUP EXPR</small>. This means that <small class="allcaps">SQL</small> Server determines at 
   <i>run-time</i>
   whether to access the table or not.</p>
<p>For your real-world case you may find it prohibitive to change the primary
   key. In this case you could add a <small class="allcaps">UNIQUE</small> constraint with the partitioning
   column + the real primary key. This will not be a proper partitioned view,
   and the view will not be updatable,
   but with some luck <small class="allcaps">SQL</small> Server may still apply startup expressions, and access only one of the base tables.
   At least I got it to work, when I ran a quick test. You
   should verify that it works for your situation.</p>
<p>When a new table is added with a new year, the view needs to be redefined. If
   this happens frequently, for instance by each month, you should probably set
   up a job for this. I leave out example code, but it requires running
   a cursor over <b>sysobjects</b> to compose a <small class="allcaps">CREATE VIEW</small> statement that you then
   execute with <b>sp_executesql</b> or <small class="allcaps"><nobr>EXEC()</nobr></small>. That would be an example of good use of
   dynamic <small class="allcaps">SQL</small>.</p>
<p>This was a very concentrated introduction to partitioned views, a feature which
   was introduced in <small class="allcaps">SQL</small>&nbsp;2000. What Microsoft had in mind was truly big tables where partitioning is desired not only for
   performance but also manageability. You can find the full rules for
   partitioned views under the topic for <small class="allcaps">CREATE VIEW</small> in Books Online. Good
   reading is also Stefan
   Delmarco's detailed article <i>
   <a href="http://www.fotia.co.uk/FA.02.Sql2KPartitionedViews.01.htm"><small class="allcaps">SQL</small>
   Server 2000 Partitioned Views</a></i>. </p>
<p>For completeness sake, I should mention that it is also possible to define
   distributed partitioned views with tables spread out over several servers.
   Furthermore, <small class="allcaps">SQL</small>&nbsp;2005 adds another partitioning feature, partitioned tables.
   I'm not detailing any of them here. </p>
<h3><a name="Dyn_update">UPDATE tbl SET @colname = @value WHERE keycol = @keyval</a></h3>
<p>In this case people want to update a column which they select at run time.
The above is actually legal in <small class="allcaps"><nobr>T-SQL</nobr></small>, but what happens is simply that the
   variable @colname
is assigned the value in @value for each affected row in the table. </p>
<p>In this case dynamic <small class="allcaps">SQL</small> would call for the user to have <small class="allcaps">UPDATE</small> permissions
on the table, something which is not to take lightly. So there is all reason to
avoid it. Here is a fairly simple workaround: </p>
<pre>UPDATE tbl
SET    col1 = CASE @colname WHEN 'col1' THEN @value ELSE col1 END,
       col2 = CASE @colname WHEN 'col2' THEN @value ELSE col2 END,
       ...</pre>
<p>
If you don't know about the <small class="allcaps">CASE</small> expression, please look it up in Books Online.
It's a very powerful <small class="allcaps">SQL</small> feature.</p>
<p>Then again, one would wonder why people want to do this. Maybe it's because their
tables look like this:</p>
<pre>CREATE TABLE products (prodid   prodid_type NOT NULL,
                       prodname name_type   NOT NULL,
                       ...
                       sales_1  money       NULL,
                       sales_2  money       NULL,
                       ...
                       sales_12 money       NULL,
                       PRIMARY KEY (prodid))</pre>
<p>
It could make more sense to move these <i>sales_n</i> columns to a second table: </p>
<pre>CREATE TABLE product_sales (prodid prodid_type NOT NULL,
                            month  tinyint     NOT NULL,
                            sales  money       NOT NULL,
                            PRIMARY KEY (prodid, month))</pre>
<h3><a name="Dyn_DB">SELECT * FROM @dbname + '..tbl'</a></h3>
<p>In this case the table is in another database which is somehow determined
dynamically. There seems to be several reasons why people want to do this, and
   depending on your underlying reason, the solution is different.</p>
<h4><a name="otherdb">Get Data from another Database</a></h4>
<p>If you for some reason have your
   application spread over two databases, what you absolutely not should do is
   to have code that says:</p>
<pre>SELECT ... FROM <font color="#ff0000">otherdb</font>.dbo.tbl JOIN ...</pre>
<p>This is bad, because if someone asks for a second environment on the same
   server, you have a lot of code to change. </p>
<p>The best solution for this particular problem on <small class="allcaps">SQL</small>&nbsp;2005, is to use 
   synonyms:</p>
<pre>CREATE SYNONYM otherdbtbl FOR otherdb.dbo.tbl</pre>
<p>You can then refer to <b>otherdb.dbo.tbl</b> as just <b>otherdbtbl</b>. If 
   there is a need for a second set of databases, you only have to update the 
   synonyms, and there is no need to use dynamic <small class="allcaps">SQL</small>.</p>
<p>Yet a way to avoid dynamic <small class="allcaps">SQL</small> is to use stored procedures for all 
   inter-database communication. That is, if you are in <b>db1</b> and need to get data from <b>
   db2</b>, you call a stored procedure in <b>db2</b>. This can be dynamic, 
   because <small class="allcaps">EXEC</small> permits you to specify a variable that holds the name of the 
   procedure to execute.</p>
<pre>SELECT @dbname = quotename(dbname) FROM ...
SELECT @sp = @dbname + '..some_sp'
EXEC @ret = @sp @par1, @par2...</pre>
<p>If you want to get result sets back from <b>db2</b>, look at my article <i>
   <a href="http://www.sommarskog.se/share_data.html">How to Share Data between Stored Procedures</a></i>
   for suggestions.</p>
<p>There may still be cases you may find that dynamic <small class="allcaps">SQL</small> is the only feasible 
   situation. This can be done in two ways. The most obvious 
   is:</p>
<pre>SELECT @dbname = quotename(dbname) FROM ...
SELECT @sql = ' SELECT ... FROM ' + @dbname + ' .dbo.otherdbtbl ' +
              ' JOIN dbo.localtbl ... '
EXEC sp_executesql @sql, @params, ...</pre>
<p>But, if the query is complex, and most of the tables are in the remote 
   database you can also do:</p>
<pre>SELECT @sql = ' SELECT ... FROM dbo.othertbl ' +
              ' JOIN ' + quotename(db_name()) + '.dbo.localtbl ... '
SELECT @dbname = quotename(dbname) FROM ...
SELECT @sp_executesql = @dbname + '..sp_executesql'
EXEC @sp_executesql @sql, @params, ...</pre>
<p>As above, I make use of that you can specify the procedure name dynamically 
   with <small class="allcaps">EXEC</small>. The trick here is that when you specify a system stored procedure 
   in three-part notation with the database name, the procedure executes in the 
   context of that database. Thus, the dynamic <small class="allcaps">SQL</small> in this example runs in 
   @dbname, not the current database.</p>
<h4><a name="everydb">Do Something in Every Database</a></h4>
<p>This sounds to me like some sysadmin
   venture, and for sysadmin tasks dynamic <small class="allcaps">SQL</small> is 
   usually a fair game, because neither caching nor permissions are issues. 
   Nevertheless there is an kind of alternative: <b>sp_MSforeachdb</b>, demonstrated by this example: </p>
<pre>sp_MSforeachdb 'SELECT ''?'', COUNT(*) FROM sysobjects'</pre>
<p>As you might guess, <b>sp_MSforeachdb</b> uses dynamic <small class="allcaps">SQL</small> internally, so
   what you win is that you don't have to write the control loop yourself. I should
   hasten to add that <b>sp_MSforeachdb</b> is not documented in Books Online,
   which also means that use of it is not supported by Microsoft and it could be
   changed or withdrawn from <small class="allcaps">SQL</small> Server without notice.</p>
<h4><a name="masterdb">A "Master" Database</a></h4>
<p>The scenario here is that you have a suite of databases with identical
   schema. The typical reason they are different databases and not one, is that every
   database serves a different customer, and each customer can access his 
   database (but of course no one else's). Some people
   see a problem with the same stored procedures in fifty databases,
   and believe that they face a maintenance nightmare. So they get the idea
   that they should put the procedures in a "master" database. Yes, you can do that. It
   will give you a much bigger maintenance problem, because your code will
   entirely littered with dynamic <small class="allcaps">SQL</small>.
   In fact, if you feel that this is the only alternative, you are better off 
   skipping stored procedures altogther and do all acecss from client code 
   instead. In such case there is only one place you need to specify the 
   database: the connection string.</p>
<p>What else can you do? Some people might suggest that you should collapse the
   databases into one, and employ a strict
   row-level security scheme. Personally, I would never accept such a solution
   as a potential customer. In a complex application, bugs can easily lead to
   that information is exposed to people who should not see it. Besides,
   row-level security cannot be implemented entirely waterproof in <small class="allcaps">SQL</small> Server.
   Whereas queries only would return the data they should, query plans and error
   messages may indirectly disclose information to users who are not authorised 
   to see it.</p>
<p>Another wild approach is to use <small class="allcaps">SQL</small> Server's own <b>master</b> database and install the application procedures
   as system procedures. This works at least in <small class="allcaps">SQL</small>&nbsp;2000 and earlier. I have not
   verified that it still does in <small class="allcaps">SQL</small>&nbsp;2005 where Microsoft's 
   own system procedures
   now reside in the invisible resource database. In any case, this is entirely
   unsupported. So while I mention the possibility, I don't give you the details
   on how to do it and I strongly recommend that you don't go there.</p>
<p>What then is the real solution? Install the stored procedures in each database and develop
   rollout routines for your <small class="allcaps">SQL</small>
objects. You need this anyway, the day you want to update the table
definitions. This also permits you to have some flexibility. Some
customers may prefer to skip an upgrade. Other customers may be
prepared to pay for extra functions that only they have access to. Even
more importantly, it permits you to easily scale out and move some
databases to a second server. I mentioned that as a customer, I would
not accept to share database with other customers. In fact, a
security-aware customer would not even accept to share the same
instance of <small class="allcaps">SQL</small> Server, but
   require his own instance.</p>
<p>(You may ask whether not synonyms could be used to implement the "master" 
   database. I have not been able to think of anything useful, but if you find 
   out something, please drop me a line.)</p>
<h3><a name="createotherdb">Creating an Object in Another Database</a></h3>
<p>This question sometimes comes up. Most often people have problems with the 
   <small class="allcaps">USE</small> command. The correct solution is to avoid <small class="allcaps">USE</small> altogether in this case. In 
   fact, we have already seen how to do this:</p>
<pre>SELECT @sql = 'CREATE VIEW ...'
SELECT @sp_executesql = quotename(@dbname) + '..sp_executesql'
EXEC @sp_executesql @sql</pre>
<p>That is, make use of that you can set the database context by calling <b>sp_executesql</b> with three-part notation.</p>
<h3><a name="List">SELECT * FROM tbl WHERE col IN (@list)</a></h3>
<p>It is fascinating how may people who put '1,2,3,4' in @list, and then are
   puzzled why the query above does not return any rows. Well, if there is a row
   where <b>col</b> has the value '1,2,3,4', you will get a match. These two
   conditions are the same:</p>
<pre>col IN (@list)
col = @list</pre>
<p>IN does <i><b>not</b></i> mean "parse whatever data there is at runtime as a
   comma-separated list". It's a <i><b>compile-time </b></i>shortcut for
   <code>col =
   @a OR col = @b OR</code> ...</p>
<p>This is a very common question on the newsgroups, and <i>Use dynamic <small class="allcaps">SQL</small></i> is a far too common answer.
   Yes, you can do this with dynamic <small class="allcaps">SQL</small>, but it is an extremely poor solution.
   You cannot pass the list as a parameter to <b>sp_executesql</b>, so you would have
   to use <small class="allcaps"><nobr>EXEC()</nobr></small> and be open to <a href="#SQL_injection"><small class="allcaps">SQL</small> injection</a>. On
   top of that, for long lists, IN has extremely poor performance – in some
   tests I did, it took <small class="allcaps">SQL</small> Server 15 seconds to build the query plan for a list
   with 10000 elements.</p>
<p>The correct method is to unpack the list into a table with a user-defined
   function or a stored procedure. In my article, <i><a href="http://www.sommarskog.se/arrays-in-sql.html">Arrays and Lists in
 <small class="allcaps">SQL</small> Server</a></i>, I describe a whole range of ways to do this. I also present performance data for the various methods. (Dynamic <small class="allcaps">SQL</small> is at
 the bottom of that list!) This is a long article, but there are jump-start
   links in the beginning of the article, depending on which version of <small class="allcaps">SQL</small>
   Server you are using.</p>
<h3><a name="Condition">SELECT * FROM tbl WHERE @condition</a></h3>
<p>If you are considering to write the procedure</p>
<pre>CREATE PROCEDURE search_sp @condition varchar(8000) AS
   SELECT * FROM tbl WHERE @condition</pre>
<p>Just forget it. If you are doing this, you have not completed the transition
   to use stored procedure and you are still assembling your <small class="allcaps">SQL</small> code in the client.
But this example lapses into</p>
<h3><a name="Dyn_search">Dynamic Search Conditions</a></h3>
<p>A not too uncommon case is that the users should be able to select data from a broad set of
parameters. The procedure <b>search_orders</b> in the section on
   <a href="#SQL_injection"><small class="allcaps">SQL</small> injection</a>
   was a very simple example of this.</p>
<p>Any programmer that tackles this realises that writing a static solution
   with a tailor-made query for each combination of input parameters is
   impossible. There are a number of ways to attack this problem, both with dynamic and
   static <small class="allcaps">SQL</small>, and I have a separate article, <i><a href="http://www.sommarskog.se/dyn-search.html">Dynamic Search Conditions</a>,</i> where I
   present several methods for this type of searches, both with dynamic <small class="allcaps">SQL</small> and 
   static <small class="allcaps">SQL. A</small> very brief summary is that
   dynamic <small class="allcaps">SQL</small> is often the best solution, both for performance and
   maintainability, as long as you can accept the permission consequences.</p>
<h3><a name="Order_by">SELECT * FROM tbl ORDER BY @col</a></h3>
<p>This can easily be handled without dynamic <small class="allcaps">SQL</small> in this way:</p>
<pre>SELECT col1, col2, col3
FROM   dbo.tbl
ORDER  BY CASE @col1
               WHEN 'col1' THEN col1
               WHEN 'col2' THEN col2
               WHEN 'col3' THEN col3
           END</pre>
<p>Again, review the <small class="allcaps">CASE</small> expression in Books Online, if you are not acquainted
with it. </p>
<p>Note that if the columns have different data types you cannot lump them into
   the same <small class="allcaps">CASE</small> expression, as the data type of a <small class="allcaps">CASE</small> 
   expression is always one and the same. Instead, you can do this:</p>
<pre>SELECT col1, col2, col3
FROM   dbo.tbl
ORDER  BY CASE @col1 WHEN 'col1' THEN col1 ELSE NULL END,
          CASE @col1 WHEN 'col2' THEN col2 ELSE NULL END,
          CASE @col1 WHEN 'col3' THEN col3 ELSE NULL END</pre>
<p>
<small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Itzik Ben-Gan had a good article on this topic in the March
2001 issue of <a href="http://www.sqlmag.com/"><small class="allcaps">SQL</small> Server Magazine</a>,
where he offers other suggestions.</p>
<h3><a name="Top">SELECT TOP @n FROM tbl</a></h3>
<p>On <small class="allcaps">SQL</small>&nbsp;2005 this is straightforward in static <small class="allcaps">SQL</small>, as with a slight syntax
   change, <small class="allcaps">TOP</small> accepts expressions for the argument:</p>
<pre>SELECT TOP(@n) col1, col2 FROM tbl</pre>
<p>On <small class="allcaps">SQL</small>&nbsp;2000, you can achieve this without dynamic <small class="allcaps">SQL</small> as in this example:</p>
<pre>CREATE PROCEDURE get_first_n @n int AS
SET ROWCOUNT @n
SELECT au_id, au_lname, au_fname
FROM   authors
ORDER  BY au_id
SET ROWCOUNT 0</pre>
<p>You may wonder whether <small class="allcaps">SQL</small> Server will consider the value of @n when building
   the query plan, and my testing indicates that it does, but:</p>
<ul>
   <li>@n must be a parameter. If @n is a local variable, the optimizer has no
      clue.</li>
   <li>If you first call <b>get_first_n</b> with @n = 10, and then @n = 10000
      you will get the same plan, although different plans may be the best
      choice for different values of @n. You can use the <small class="allcaps">WITH RECOMPILE</small> option to
      address this problem, either with the <small class="allcaps">CREATE PROCEDURE</small> statement or when you
      execute the procedure.</li>
   <li>This applies to <small class="allcaps">SQL</small>&nbsp;7 and later. Then again, on <small class="allcaps">SQL</small>&nbsp;6.5, you don't
      have any other choice, as it does not support <small class="allcaps">SELECT TOP</small> at all.</li>
   <li>You should remember to say <small class="allcaps">SET ROWCOUNT</small> 0 after the <small class="allcaps">SELECT</small>.</li>
</ul>
<p>It can be disputed whether <small class="allcaps">SET ROWCOUNT</small> @n is really a better solution than
   running a dynamic <small class="allcaps">SQL</small> statement with <small class="allcaps">TOP. A</small> dynamic <small class="allcaps">TOP</small> is probably a
   better choice, as long as you can accept the security implications. (But it's
   not worth to change the permissions only for this.)</p>
<p>I guess a common reason for wanting to do this is to implement paging in web
   applications. <small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Aaron Bertrand has an article which is the
   <a href="http://www.aspfaq.com/show.asp?id=2120">standard reference</a> on
   this topic. </p>
<h3><a name="Cre_tbl">CREATE TABLE @tbl</a></h3>
<p>The desire here is to create a table of which the name is determined at
   run-time.</p>
<p>If we just look at the arguments against using dynamic <small class="allcaps">SQL</small> in stored
   procedures, few of them are really applicable here. If a stored procedure has a
   static <small class="allcaps">CREATE TABLE</small> in it, the user who runs the procedure must have
   permissions to create tables, so dynamic <small class="allcaps">SQL</small> 
   will not change anything. Plan caching obviously has nothing to do with
   it. Etc.</p>
<p>Nevertheless: <i> <b>Why? Why would you want to do this?</b></i> If you are creating tables on the fly in your
   application, you have missed some fundamentals about database design. In a
   relational database, the set of tables and columns are supposed to be
   constant. They may change with the installation of new versions, but not during
   run-time. </p>
<p>Sometimes when people are doing this, it appears that they want to construct
unique names for temporary tables. This is completely unnecessary, as this is a
built-in feature in <small class="allcaps">SQL</small> Server. If you say:</p>
<pre>CREATE TABLE #nisse (a int NOT NULL)</pre>
<p>then the actual name behind the scenes will be something much longer, and no
other connections will be able to see this instance of <b>#nisse</b>.</p>
<p>If you want to create a permanent table which is unique to a user, but you
   don't want to stay connected and therefore cannot use temp tables, it may be
better to create one table that all clients can share, but where the first
column is a key which is private to the client. I discuss this method a little
   more closely in my article <i><a href="http://www.sommarskog.se/share_data.html#prockeyed">How to
   Share Data between Stored Procedures</a></i>.</p>
<h3><a name="unknowncolumns">CREATE TABLE with Unknown Columns</a></h3>
<p>Sometimes I see persons on the newsgroups that are unhappy, because they
 create a temp table from dynamic <small class="allcaps">SQL</small>, and then they can't access it, because it
 disappeared when the dynamic <small class="allcaps">SQL</small> exited. When told that they have to create the
 table outside the dynamic <small class="allcaps">SQL</small>, they respond that they can't, because they don't
 know the structure of the table until run-time.</p>
<p>One solution is to create a global temp table, one with two # in the name,
 for instance <b>##temp</b>. Such a table is visible to all processes (so you may have
 to take precautions to make the name unique), and unless you explicitly drop it, it exists
 until your process exits.</p>
<p>But the real question is: <i> <b>what are these guys up to?</b></i> If you are
   working with a relational database, and you don't know the structure of your
   data until run-time, then there is something fundamentally wrong. As I have
   never been able to fully understand what the underlying business requirements 
   are, I can't really provide any alternatives. But I would suggest that if you
   need to go this road, you should seriously consider to run your <small class="allcaps">SQL</small> from a client
   program. Because, all access
   to that table would have to be through dynamic <small class="allcaps">SQL</small>, and composing
   dynamic <small class="allcaps">SQL</small> strings is easier in languages with better string capabilities,
   be that <small class="allcaps">C#, VB</small> or Perl. </p>
<p>OK, so there is one case where I can see people end up here, and that is if you
   want to run a dynamic crosstab – which definitely isn't a very relational
   operation, but neverthless is a very common user requirement. You may want to look at
   <a href="http://www.rac4sql.net/"><small class="allcaps">RAC</small></a>, a third-party product. I have not
   used it myself, but I've heard reports from satisfied users.</p>
<h3><a name="linkservers">Linked Servers</a></h3>
<p>This is similar to parameterising the <a href="#Dyn_DB">database name</a>,
   but in this case we want to access a linked server of which the name is
   determined at run-time.</p>
<p> Two of the solutions for dynamic database names apply here as well:</p>
<ul>
   <li>On <small class="allcaps">SQL</small>&nbsp;2005, the best solution is probably to use synonyms:
      <pre>CREATE SYNONYM myremotetbl FOR Server.db.dbo.remotetbl.</pre></li>
   <li>If you can confine the access to the linked server to a stored procedure
      call, you can build the SP name dynamically:
<pre>SET @sp = @server + 'db.dbo.some_sp'
EXEC @ret = @sp @par1, @par2...</pre></li>
</ul>
<p>
If you want to join a local table with a remote table on some remote server,
determined in the flux of the moment, dynamic <small class="allcaps">SQL</small> is probably the best way if
you are on <small class="allcaps">SQL</small>&nbsp;2000.
There exists however an alternative, although it's only usable in some
situations. You can use <b>sp_addlinkedserver</b> to define the linked server at 
run-time,
as demonstrated by this snippet:</p>
<pre>EXEC sp_addlinkedserver MYSRV, @srvproduct='Any',
                               @provider='SQLOLEDB', @datasrc=@@SERVERNAME
go
CREATE PROCEDURE linksrv_demo_inner WITH RECOMPILE AS
   SELECT * FROM MYSRV.master.dbo.sysdatabases
go
EXEC sp_dropserver MYSRV
go
CREATE PROCEDURE linksrv_demo @server sysname AS
   IF EXISTS (SELECT * FROM master..sysservers WHERE srvname = 'MYSRV')
      EXEC sp_dropserver MYSRV
   EXEC sp_addlinkedserver MYSRV, @srvproduct='Any',
                           @provider='SQLOLEDB', @datasrc=@server
   EXEC linksrv_demo_inner
   EXEC sp_dropserver MYSRV
go
EXEC linksrv_demo 'Server1'
EXEC linksrv_demo 'Server2'</pre>
<p>
There are two procedures. <b>linksrv_demo_inner</b> is the procedure where we
actually access the linked server. As the linked server must exist when the
procedure is created, I first create a dummy entry for <small class="allcaps">MYSRV</small>, which I subsequently
drop once the procedure has been created. (Not only must the linked server exist, it must also have the database and
tables that you access.) <b>linksrv_demo</b> is the outside interface which takes a
server name as a parameter, and then at run-time defines <small class="allcaps">MYSRV</small> to point to
@server.</p>
<p>
The above is only possible under certain conditions:</p>
<ul>
   <li>The procedure must be run by someone who has privileges to set up
    linked servers, normally only the roles <b>sysadmin</b> and <b>setupadmin</b>
    have these permissions. Thus, plain users do not apply.</li>
    <li>Since you change a
     server-wide definition, you cannot have several instances of the procedure
     running. (It goes without saying, that you should use the alias in this
       procedure only.)</li>
</ul>
<p>
As you can see in the example, I've added <small class="allcaps">WITH RECOMPILE</small> to <b>linksrv_demo_inner</b>.
This is a safety precaution, to prevent that a cached plan does not access a
different server. I don't think this is really necessary, as <small class="allcaps">SQL</small> Server should sense the
changed definition. In fact, you may not even have to split the code over two
procedures, but as they say, better safe than sorry.</p>
<h3><a name="OPENQUERY">OPENQUERY</a></h3>
<p>The rowset functions <small class="allcaps">OPENQUERY</small> and <small class="allcaps">OPENROWSET</small> often calls for dynamic <small class="allcaps">SQL</small>. Their second argument
    is an <small class="allcaps">SQL</small> string, and they do no accept variables.
   (This is because the optimizer builds a plan for the distributed query when
   the procedure is compiled.) So any single parameter you want to pass to the
   <small class="allcaps">SQL</small> statement for that remote server requires you to use dynamic <small class="allcaps">SQL</small>. Since the
   remote <small class="allcaps">SQL</small> string can include string literals, you 
   may have to deal with up to three
   levels of nested quotes. If you don't watch out, you can spend a full day
   looking at things like:</p>
<pre>DECLARE @sql varchar(8000)
SELECT @sql = 'SELECT * FROM OPENQUERY(MYSRV, ' +
              '''SELECT * FROM Northwind.dbo.Orders ' +
              'WHERE CustomerID = N''''VINET'''''')'
PRINT @sql
EXEC(@sql)</pre>
<p>and then try to find out if you might you have one <code>'</code> too many or too
   few. </p>
<p>Strict discipline is absolutely necessary when working with dynamic <small class="allcaps">SQL</small> for
   <small class="allcaps">OPENQUERY</small>. The function <a href="#quotestring"><b><nobr>quotestring()</nobr></b></a>
   that I showed you earlier can be of great help:
</p>
<pre>DECLARE @remotesql nvarchar(4000),
        @localsql  nvarchar(4000),
        @state     char(2)

SELECT @state = 'CA'
SELECT @remotesql = 'SELECT * FROM pubs.dbo.authors WHERE state = ' +
                     dbo.quotestring(@state)
SELECT @localsql  = 'SELECT * FROM OPENQUERY(MYSRV, ' +
                     dbo.quotestring(@remotesql) + ')'

PRINT @localsql
EXEC (@localsql)</pre>
<p>The built-in function <b><nobr>quotename()</nobr></b> is usually not useful here, as the <small class="allcaps">SQL</small> statement easily
   can exceed the limit of 129 characters for the input parameter to <b>
   <nobr>quotename()</nobr></b>.
</p>
<p>On <small class="allcaps">SQL</small>&nbsp;2005, you can use <small class="allcaps"><nobr>EXEC()</nobr></small> to run an <small class="allcaps">SQL</small> statement on a 
   <a href="#EXECatlinked">linked
   server</a>. Since <small class="allcaps"><nobr>EXEC()</nobr></small> at linked servers can take parameters, this can make
   things considerably easier. Then again, you can join <small class="allcaps">OPENQUERY</small> with local
   tables, so that only rows of interest are brought across the wire. This you 
   cannot do with <small class="allcaps"><nobr>EXEC()</nobr></small>.</p>
<h3><a name="Col_width">Dynamic Column Widths</a></h3>
<p>Say that you write a stored
   procedure that is to present some data, and the <small class="allcaps">GUI</small> it is to be run from is
   Query Analyzer or <small class="allcaps">SQL</small> Server Management Studio (presumably because it is a sysadmin procedure). To make the
   output easy to digest, you want the column width to be so wide that no data
   is truncated, but neither do you want any extraneous spaces. This is
   something you can achieve with dynamic <small class="allcaps">SQL</small>. Typically you would use a temp table
   to hold the data, in which case there are no permission issues. </p>
<p>Rather than giving an example, I refer you to the source code for the popular (but undocumented)
   system procedure <b>sp_who2</b>. You can find the code by entering <b>exec
   master..sp_helptext sp_who2</b>.</p>
<h3><a name="maintenancetasks">Dynamic SQL and Maintenance Tasks</a></h3>
<p>I've written this text with a main focus on application code, because it is
   mainly in application tasks, bad usage of dynamic <small class="allcaps">SQL</small> can cause serious harm
   by opening for <a href="#SQL_injection"><small class="allcaps">SQL</small> injection</a>, poor
   <a href="#queryplans">query-plan reuse</a>, and result in code that is
   difficult to read and maintain.</p>
<p>Here, I like to briefly discuss code that is for maintenance jobs, code that 
   run once a
   night or once a week or even less frequently. Generally, for this sort of
   code, dynamic <small class="allcaps">SQL</small> is almost always a fair game. Query
   plans are rarely an issue. And if the code is to be run by users with <b>
   sysadmin</b> privileges, there are no permissions issues. The same applies to
   code that does not require permissions outside the database, and is to be run
   by users with <b>db_owner</b> privileges.</p>
<p>There are however, two points about <small class="allcaps">SQL</small> injection I like to make.</p>
<ol>
   <li>If you are a <small class="allcaps">DBA</small> that writes some stored procedure to be run by junior
   operators that do not have <b>sysadmin</b> privilege themselves, you must of
   course take precaution against <small class="allcaps">SQL</small> injection, so that they don't outsmart
   you.</li>
   <li>If you write a job that performs operations on tables in
   every database, be careful to use <nobr><b>quotename()</b></nobr> when you build the <small class="allcaps">SQL</small> strings.
   This is particularly important if there are non-sysadmin users that own
   databases. A user could create a table name that injects an <small class="allcaps">SQL</small> command 
      into
   your maintenance script when you run it. If you are the <small class="allcaps">DBA</small> at a hosting
   company, this is a risk that you definitely should not neglect.</li>
</ol>
<h2><a name="Feedback">Acknowledgements and Feedback</a></h2>
<p>I like to thank the following persons who have provided valuable suggestions
   and input for this article: <small class="allcaps">SQL</small> Server MVPs Tibor Karaszi, Keith Kratochvil,
   Steve Kass, Umachandar Jaychandran, Hal Berenson and Aaron Bertrand, as well as Pankul Verma,
   Anthony Faull, Karl Jones, Marcus
   Hansfeldt, Jeremy Lubich and Simon Hayes. </p>
<p>I also like to thank the people who have made the effort to provide
   translations of the older version article: <small class="allcaps">ASP MVP</small> Jongshin Kim wrote the
   <a href="http://itcontents.com/sommar/dynamic_SQL.html">Korean</a>
   translation. <small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Frank Kalis translated into
   <a href="http://www.insidesql.de/content/view/164/29/">German</a>
   and Simon Hayes into <a href="http://www.hayes.ch/sql/sql_dinamico.html">
   Spanish</a>. Tam Vu translated the article into
   <a href="http://vuhuytam.com/sql/dynamic_sql.html">Vietnamese</a>.</p>
<p>If you have suggestions for improvements or corrections on contents, language or
formatting, please mail me at <a href="mailto:esquel@sommarskog.se">
   esquel@sommarskog.se</a>.
If you have technical questions that any knowledgeable person could answer, I encourage you to
post to any of the newsgroups <a href="news:microsoft.public.sqlserver.programming">microsoft.public.sqlserver.programming</a> or <a href="news:comp.databases.ms-sqlserver">comp.databases.ms-sqlserver</a>.</p>
<h2><a name="revisions">Revision History</a></h2>
<p><b>2006-07-25</b> – Corrected syntax in example with <a href="#cursor0">
   cursor variable</a> after comment from Anthony Faull.</p>
<p><b>2006-04-28</b> – A
   <a href="http://vuhuytam.com/sql/dynamic_sql.html">Vietnamese</a> translation 
   (of the old version) is now available.</p>
<p><b>2006-04-23</b> – Thoroughly reworked the article to cover <small class="allcaps">SQL</small>&nbsp;2005 in
   full, resulting in lots of new text, lots of old text dropped, and many 
   sections rearranged. I'm now
   more strongly favouring <b>sp_executesql</b> over <small class="allcaps"><nobr>EXEC()</nobr></small>, and 
   I put more stress on <small class="allcaps">SQL</small>
   injection. I also stress the importance of using parameterised statements for 
   query-plan reuse, and I note that prefixing with <b>dbo</b> is essential for 
   query-plan reuse. The examples of cases where (not) to use dynamic <small class="allcaps">SQL</small> have 
   had an overhaul as well, if not equally drastic. I'm now giving a very quick 
   example of partitioned views for the sales + @yymm case. The article now also 
   includes snippets for
   parameterised commands from VB6 and VB .Net.</p>
<p><b>2005-04-17</b> – Added <a href="#sp_executesqlong">example</a> of <small class="allcaps">EXEC</small> + <b>
   sp_executesql</b> with <small class="allcaps">OUTPUT</small> parameter. Added use of <b>nvarchar(max) </b>on
   <small class="allcaps">SQL</small>&nbsp;2005 for <a href="#quotestring">quotestring</a> and elsewhere.</p>
<p><b>2004-05-30</b> – <a href="http://www.hayes.ch/sql/sql_dinamico.html">
   Spanish</a> translation now available.</p>
<p><b>2004-02-08</b> –
   <a href="http://www.insidesql.de/content/view/164/29/">German</a> translation now available. Minor language corrections.</p>
<p><b>2003-12-02</b> – <a href="http://itcontents.com/sommar/dynamic_SQL.html">
   Korean</a> translation now available. Added example of using
   <a href="#cursor0">cursor</a> variable with dynamic <small class="allcaps">SQL</small>. Modified description
   of first parameter to <a href="#sp_executesql"><b>sp_executesql</b></a>.</p>
<p align="right"><a href="http://www.sommarskog.se/index.html">Back to my home page</a>.</p>

</body></html>